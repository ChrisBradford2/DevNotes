---
description: Dans cette formation, qui s'adresse aux développeurs d'applications et d'interfaces utilisateur (UI) mobiles, vous découvrirez Flutter, le framework open source de Google.
slug: /l-essentiel-de-flutter
tags:
  - Mobile
  - Dart
---

# L'essentiel de Flutter

Vous entendez souvent parler de Flutter, cet outil développé par Google et qui permet d'écrire facilement de belles applications multi-platforme ? Alors venez découvrir de quoi il s'agit vraiment. Nous verrons pas à pas ce que Flutter permet de faire, puis je vous guiderez pour que vous appreniez à développer aisément des applications mobiles qui fonctionneront aussi bien sur Android que sur iOS. Si vous souhaitez vous ouvrir au monde de Flutter, et découvrir les nombreuses possibilités qu'il offre, alors n'attendez plus et commençons ensemble cette formation !

## Démarrer avec Flutter

### Comprendre le rôle de Flutter

#### Qu'est ce que Flutter ?

Flutter est un *toolkit*, une boite à outils, qui a été créé par le géant du web **Google**. C'est un *toolkit* qui est orienté UI (User Interface) et on comprend par là que l'accent est mis sur l'interface utilisateur et que le développement d'une application Flutter va s'articuler autour de ce concept-là. Flutter va nous permettre de créer des applications multiplateformes puisque l'on va pouvoir développer des applications mobiles pour Android et iOS, des applications web ou encore, des applications de bureau. Pour Windows, pour MacOS ou pour Linux. Enfin, Flutter s'appuie sur le langage **Dart**. Le langage **Dart** est un langage qui a été créé par Google, assez récent puisque la première version a été mise à disposition en fin 2013 ; et **Dart** va reprendre des concepts que l'on retrouve dans d'autres langages qui vont nous permettre justement de pouvoir rapidement rentrer dans le bain. 

#### Pourquoi utiliser Flutter ?

L'avantage de Flutter est que l'on va pouvoir réutiliser toutes ou parties de notre code pour diverses plateformes. Cela aura pour conséquence de réduire la mise à disposition d'une application sur le marché. Par exemple, on va pouvoir très rapidement, mettre notre application sur le Play Store ou sur L'App Store. Mais également, on va ne plus avoir besoin de diverses compétences. En effet, pour développer sur Android ou iOS, cela retient des compétences qui sont diverses. Par exemple sur Android, il va falloir connaître le langage Java ou Kotlin et sur iOS, il va au moins falloir connaître le langage Objective-C ou Swift. Avec Flutter, il n'y a plus qu'un seul langage : le langage **Dart**. Enfin, le fait d'avoir un seul code pour plusieurs plateformes va faire que, en cas de problème, on n'aura plus qu'un seul code à maintenir, ce qui va nous faire gagner un temps considérable. D'ailleurs, en parlant de temps, Flutter va nous permettre de réduire le temps de développement. Ça fait référence au fait que Flutter nous offre des fonctionnalités qui vont nous permettre de rapidement tester notre code en voyant l'impact de manière quasi instantanée. En effet, si on prend l'exemple du cas du développement sur Android, même si cela était amélioré au fur et à mesure des différentes versions, si vous faites une modification dans votre code et que vous souhaitez voir le résultat sur un émulateur ou sur votre téléphone, quelques secondes vont s'écouler. Bien sûr, ces secondes vont dépendre aussi de la configuration de votre ordinateur, mais avec Flutter, le résultat sera lui, quasi instantané. Flutter va nous proposer de bonnes performances. puisque Flutter compile de manière native, ce qui va lui conférer d'excellentes performances qui sont proches de ce que l'on peut obtenir en faisant du développement natif. Un des points essentiels à tout outil de développement est la documentation qui s'y rattache. Ici, Google a fait un bel effort en proposant une documentation qui est assez riche, mais aussi, on trouvera sur internet de nombreux sites, de nombreux blogs qui traitent de Flutter puisque la communauté ne cesse de croître. D'ailleurs, de nombreuses entreprises ont adopté Flutter. Pour n'en citer que quelques-unes, il y a bien sûr Google avec l'application Google Ads, mais également le groupe Ali Baba, eBay ou encore Groupon. Dans cette vidéo, nous avons ainsi vu qu'est-ce que Flutter et quelles sont les raisons qui peuvent nous pousser à l'utiliser.

### Connaître les prérequis

- **Comprendre les principes de base de la programmation**
  - Variables
  - Boucles
  - Fonctions
  - Classes

- **Avoir un Mac si développement IOS** : Dans le cas où vous souhaiteriez développer des applications pour iOS, ou encore pour Mac OS, il est nécessaire d'avoir un ordinateur de marque Apple. Il est vrai que Flutter permet de faire du multi-plateformes, et que donc par définition le code que nous allons écrire est censé fonctionner sur iOS. Néanmoins vous ne pourrez pas tester votre code sur votre téléphone iPhone, même sur un simulateur iPhone, ni même compiler votre application pour iOS si vous êtes sur Windows ou Linux. C'est une restriction qui est indépendante de Flutter, mais seuls les ordinateurs Mac fournissent l'environnement de travail et qui nous permet de compiler des applications Mac OS et iOS et qui offre un simulateur iOS.

### Aborder le langage Dart

#### Langage créé par Google

Dart est un langage de programmation orienté Objet qui a donc été créé par Google et qui depuis sa première version en novembre 2013 n'a cessé d'évoluer en ajoutant progressivement de nouvelles fonctionnalités et en se stabilisant. Le fait que ce soit Google qui ait créé ce langage, fait que Google en connaît non seulement les points forts et les points faibles, mais surtout, au fur et à mesure que de nouvelles versions de Flutter sont créées, Dart peut à son tour être plus aisément adapté. 

#### Facile à apprendre

C'est un langage qui est réputé facile à apprendre puisqu'il reprend de nombreux concepts que l'on retrouve dans les langages les plus utilisés ; ainsi, si vous avez déjà codé en Java, en C# ou en JavaScript, vous aurez cette impression de familiarité qui vous permettra de rapidement prendre en main Dart.

#### Permet de faire du *hot reload*

Le hot reload est une fonctionnalité proposée par Flutter qui permet de voir de manière quasi instantanée, le résultat produit par une modification de votre code sans pour autant avoir besoin de recharger l'application. Ainsi, admettons que vous souhaitiez modifier le titre d'un texte, cela sera immédiat et les données que vous aviez préalablement saisies ne seront pas réinitialisées.

#### Evite l'affichage saccadé

Ce langage va éviter d'avoir un affichage saccadé, en particulier avec les animations, ce qui va fluidifier les applications et améliorer l'expérience utilisateur.

#### Plus besoin de fichiers séparés pour le layout

Enfin, Dart va également nous éviter d'avoir recours à des fichiers séparés pour créer l'interface utilisateur en le décrivant directement dans le code. En d'autres termes, nous n'avons pas besoin d'un fichier XML ou d'un « storyboard » pour créer nos « layouts ». Nous avons ici vu certaines des raisons qui ont poussé Google à faire le choix du langage Dart pour Flutter.

### Développer des applications mobiles

Conçu initialement pour permettre de créer des Applications mobiles pour Android et iOS, Flutter ne cesse d'évoluer en prenant en charge de plus en plus de systèmes d'exploitation, que ce soit de manière aboutie ou non. Comprenez par là que parfois il peut s'agir de premières versions de test. Il est ainsi possible de s'essayer à faire des applications web ou des applications pour ordinateur. Néanmoins, dans cette formation nous allons nous restreindre à l'utilisation de Flutter dans un cadre de création d'applications mobiles. Cela ne veut pas dire que tout ce qui est enseigné n'est pas réutiisable ailleurs, bien au contraire. Il faudra seulement adapter certaines notions, mais la majorité de ce qui est vu est applicable à tout type d'application faite avec Flutter. Je vous invite donc à aller visiter le site officiel qui est flutter.dev pour avoir plus d'informations sur les autres plateformes.

## Découvrir le language Dart

### Appréhender les variables et les types de données simples

Nous allons voir quelle est la syntaxe pour déclarer une variable, et quels sont les types de données simples proposées par Dart. Je vous invite à aller sur le site [dartpad.dev](https://dartpad.dev) qui est un outil open source nous permettant d'éditer et d'exécuter du code Dart directement depuis un navigateur web.

#### Commentaires

```js title='main.dart'
// Ceci est un commentaire sur ligne simple

/*
 * Ceci est un commentaire
 * 
 * sur ligne
 * 
 * multple
 */
```

#### Déclarer une variable

La syntaxe pour déclarer une variable est la suivante :

```js title='main.dart'
type nomVar;

//ou

type nomVar = valeur;
```

:::caution

En **Dart**, toute instruction doit se terminer par un point virgule `;` .

:::

#### Types

- num (int / double);
- bool
- String

#### Exemple

```js title='main.dart'
int age;
int age2 = 25;

double = 1.5;

bool IsMarried = false;

String s1 = "Bonjour l'ami";
String s2 = 'Bonjour l\'ami';

String msg = 'Hello world';
print(msg); //affiche la vaiable msg dans la console.
```

```bash title='console'
Hello world
```

:::note

Pour utiliser des guillements à l'intérieur des guillements ou des caractère spéciaux, il faut mettre un backslash devant le caractère : `\' , \" , \\`

:::

Jusqu'à présent, j'ai défini les types, mais je peux aussi utiliser le mot clé `var` qui va me permettre de déduire automatiquement le type de la variable. Admettons, si j'ai `var` a et que je initialise avec la valeur 5, a sera automatiquement déduit comme étant un entier que l'on peut voir ici.

```js title='main.dart'
var a = 5; //var détecte automatiquement quel type utiliser
```

Si je crée une variable b et que je l'initialise avec la valeur `true`, b sera bien un `booléen`. Par contre, cela ne me permet pas de changer le type de b. Si je souhaite à présent que b est de type `booléen`, lui affecter la valeur 25, cela n'est pas possible puisque 25 est de type entier. Si je souhaite faire cela, j'utiliserais le type `dynamic`.

#### Type `dynamic`

Le type `dynamic` va effectivement nous permettre d'utiliser une variable tout en lui modifiant son type. Je peux l'initialiser à 5, et ensuite, lui attribuer une valeur `booléen`, ou encore, une chaîne de caractères.
Donc, la différence entre var est `dynamic`, eh bien, que var va tout simplement déduire le type, tandis que `dynamic` va nous permettre d'utiliser pour une seule variable différents types durant toute la durée de vie de la variable.

```js title='main.dart'
dynamic x = 5;
x = true;
x = "Hello";
```

### Utiliser l'interpolation de string

```js title="main.dart"
int age = 21;

print('Vous avez '+ age.toString() + ' ans !');
//Le + est un opérateur de concaténation, c'est-à-dire qu'il va permettre de mettre bout à bout des chaînes de caractères.
//Le toString() converti le type en string

print('Vous avez $age ans !');
//La façon recommandée par Dart est d'ajouter un $ avant la variable.

print('Dans 10 ans, vous aurez ${age + 10} ans !');
//Les accolades permettent d'effectuer des opérations.
```

```bash title="console"
Vous avez 21 ans !
Vous avez 21 ans !
Dans 10 ans, vous aurez 31 ans !
```

### Aborder les listes

```js title='main.dart'
List eventNumbers = [2, 4, 6, 0, 8, 2];
print (eventNumbers[2]); //Affichier un élément à une posiiton donnée.
  
List<int> oddNumbers = [1, 3, 5];
oddNumbers.add (7); //ajoute un nombre à la liste
print(oddNumbers); //affiche la liste
print(oddNumbers.length); //affiche la longueur de la liste

//spead operator
var newList =[...oddNumbers, ...eventNumbers, 8, 9];
print(newList); //Affiche la concaténation des deux précédentes listes plus le nombre 8 et 9
```

```bash title='console'
6

[1, 3, 5, 7]
4

[1, 3, 5, 7, 2, 4, 6, 0, 8, 2, 8, 9]
```

:::note

Une liste débute toujours par l'indice zéro.

:::

### Mettre en œuvre les boucles et les conditions

```js title='main.dart'
void main() {
  var user = 'Chris' ;
  if (user != null) {
    print('Bienvenue $user');
  } else {
    print('Bienvenue visiteur');
  }
  
  print('Bienvenue ${user ?? 'visiteur'}');
  
  if (user == 'Chris')
    print('Accès admin');
  
  //--------------
  for (var i = 0; i <= 5; i++){
    print('$i');
  }
  
  var players = ['John', 'Martin', 'Mélissa'];
  for (var i = 0; i < players.length; i++) {
    print(players[i]);
  }
  
  for (var player in players)
    print(player);
  
  //----------
  
  var a = 10;
  while (a > 5) {
    a = a - 1; //a--
  }
  print(a);
}
```

```bash title='console'
Bienvenue Chris
Bienvenue Chris
Accès admin
0
1
2
3
4
5
John
Martin
Mélissa
John
Martin
Mélissa
5
```

### Écrire des fonctions



### Comprendre les classes et les constructeurs

Nous allons voir comment créer des classes et comment les utiliser. Je vais commencer par créer une nouvelle classe que j'appellerai Person Pour ce faire, j'utilise le mot clé class suivi du nom de ma classe. Dans son corps, je vais mettre une propriété que j'appellerai name et définir mon constructeur. Un constructeur s'écrit en mettant le nom de la classe avec des paramètres, donc, des parenthèses et un corps. Ici, je vais initialiser ma propriété name, je vais donc mettre var name ou tout autre nom et je pourrai initialiser ma propriété en faisant this.name pour y référence, est égal à mon paramètre. Dart nous permet aussi de simplifier cette écriture. Je peux ainsi supprimer le corps de mon constructeur, mettre un point virgule, et mettre directement « this.name ». Si l'on a besoin d'écrire plusieurs constructeurs, il y a la possibilité de créer des constructeurs nommés. Il suffit alors d'écrire le nom du constructeur, comme ici Person, suivi d'un point, et du nom qui sera donné à ce nouveau constructeur. Je vais donc mettre fromPerson puisque ce constructeur-là me permettra de créer une personne à partir d'une autre. Dans le corps, je ferai tout simplement name, donc, ma propriété est égale à p. Et j’accéderai à la propriété de ce paramètre en mettant « p.name. ». Là aussi, Dart me permet de simplifier l'écriture. En effet, si je souhaite initialiser des propriétés, je peux reprendre cette ligne-là, la couper, et venir à cet endroit-là et mettre deux points et faire l'affectation. Si jamais j'avais d'autres propriétés à initialiser, je pourrais les séparer avec des virgules. Aussi, dans le cas où le corps de mon constructeur est vide, je peux le supprimer et terminer par un point virgule. Enfin, si j'ai encore deux constructeurs et qu'à l'intérieur, admettons, j'ai une instruction comme « print('fin du constructeur') », il faut savoir que tout ce qui sera après les deux points, comme ici, sera initialisé avant le corps du constructeur. Je vais terminer avec l'écriture d'une méthode. Je rappelle qu'une méthode est tout simplement une fonction au sein d'une classe, je vais donc créer la méthode speak qui va afficher un message de présentation. « Bonjour je m'appelle », et je mets $name pour faire référence à la propriété. Je vais maintenant instancier ma classe en créant un premier objet. Donc, je mets Person qui est le type de ma classe, suivi du nom de mon objet. Ici, je mettrais p1 et je mettrai « new Person() ». Vu que j'ai besoin de passer un paramètre, je mettrai un prénom, admettons Sylvie. Le mot clé new est facultatif. Je ne suis pas obligé de le mettre, et d'ailleurs, il est recommandé de ne plus le mettre. Je vais ainsi pouvoir accéder à la propriété name en faisant p1.name. Si je souhaite l'afficher, je ferais « print(p1.name) ». J'en profite pour préciser qu'en Dart, il n'y a pas de mots clés tels que private, public ou protected. Si jamais je souhaitais rendre la propriété name privée, je lui mettrai un underscore, et cela aurait pour conséquence de ne le rendre visible qu'au sein de la même librairie. En d'autres termes, qu'au sein du même fichier, sachant qu'en Dart, dans un seul fichier, on peut inclure plusieurs classes. Je vais maintenant créer une seconde personne, Person p2, et je vais faire appel à mon constructeur nommé, donc, fromperson et je vais passer en paramètre p1. Enfin, je vais faire appel à la méthode speak. Si j'exécute mon code, j'ai bien le premier print, Sylvie, la construction de ma seconde personne avec le message fin du constructeur, et enfin, le message à travers p2.speak où j'affiche « Bonjour je m'appelle Sylvie ». Nous avons ainsi vu comment nous pouvons créer des classes, créer des constructeurs et des constructeurs nommés, des propriétés, des méthodes, et comment instancier des classes.

### Assimiler la notion d'héritage

Abordons la notion d'héritage. Nous avons ici une classe Person qui a une propriété name, un constructeur qui permet d'initialiser cette propriété et enfin, une méthode qui permet de présenter la personne. Je vais créer une nouvelle classe que j'appellerais « Employee » Un employé étant une personne, je vais pouvoir étendre la classe Person, pour cela, j'utilise le mot-clé « extends » suivi du nom de la classe à étendre. J'ajouterai une propriété que j'appellerais « jobName » et qui me permettra de connaître le métier de l'employé. Je vais à nouveau créer un constructeur qui permettra d'initialiser jobName. Étant donné qu'un employé est une personne, cet employé-là aura forcément un nom. Je demanderai qu'on me le passe en paramètre, je mettrai var name et pour pouvoir transmettre cette information-là au constructeur de la classe Person, je mettrai deux points et j'utiliserai le mot-clé « super » qui prendra en paramètre name. Maintenant, si je crée une instance de ma classe Employee, je vais lui passer le jobName, ici, je mettrai « Développeur » et le prénom : Dimitri. Étant donné que l'employé est une personne, je vais pouvoir faire appel à cette méthode speak. Je vais donc pouvoir faire e.speak. Si j'exécute mon code, j'aurai bien : « Bonjour, je m'appelle Dimitri. » Maintenant, si je souhaite redéfinir ma méthode speak, si je souhaite la personnaliser pour un employé, je viendrai dans la classe Employee, j'utiliserai l'annotation override qui va me permettre d'indiquer au compilateur que la modification que je vais faire est intentionnelle et je reprendrai la méthode que je vais copier ici et coller dans la classe Employee pour apporter une modification : « Bonjour, je m'appelle $name et je travaille en tant que $jobName. » Si maintenant, je ré-exécute mon code, j'aurai bien : « Bonjour, je m'appelle Dimitri et je travaille en tant que développeur. » Nous avons vu ici comment créer une classe qui hérite d'une autre classe, comment utiliser le mot-clé « super » pour faire appel au constructeur de la classe parente et enfin, nous avons vu comment redéfinir une méthode.

### Employer les mots-clés Const et Final

Dart propose deux façons de définir des constantes que je vous propose de découvrir dans cette vidéo. Pour écrire une variable jusqu'à présent, on faisait var a, admettons que je lui donne la valeur cinq. Je peux par la suite, modifier la valeur de a et lui attribuer la valeur 70. Les deux façons proposées par Dart pour définir des constantes sont à travers l'utilisation des mots-clés « const » et « final ». Si je fais const b = 5, bien évidement, cela fonctionne, mais je ne pourrai pas modifier b par la suite. Donc, cette ligne de code me générera une erreur. Je vais donc la mettre en commentaire. Pareillement, pour final, si je mets c = 5, à la définition, cela fonctionnera, mais je ne pourrai pas faire de modification. J'aurai un message d'erreur. Voilà pour les points communs entre const et final. Maintenant, voyons les différences. La principale différence est que const doit avoir des valeurs connues à la compilation. Alors que final peut avoir des valeurs qui ne seront connues que lors de l'exécution. Je vais prendre un exemple : pour avoir l'heure courante, je peux faire appel à DateTime .now. Si je l'utilise avec un const, const now = DateTime.now, cela va me générer à nouveau une erreur, étant donné que l'heure ne sera connue qu'à l'exécution de notre programme et non à sa compilation. En revanche, si je fais final now = DateTime.now, tout fonctionnera. Aussi, je pourrai faire « const abis = 5 », cela fonctionne bien évidement, mais je ne pourrai pas faire const abis est égal à a puisque a, du moins son contenu, ne sera connu que lors de l'exécution du programme. Donc là aussi, ce n'est pas possible, alors que ça fonctionnerait avec le final. Enfin, voyons l'utilisation de const et de final avec des collections. On va, pour illustrer cela, utiliser une liste. Donc, je vais faire final list 1 = 1 et 2 et je vais faire const list 2 = 3 et 4, donc nous avons deux listes. La première étant une liste final et la seconde, une liste const. Je pourrais faire ainsi list 1 crochets 0 et je pourrais en modifier le contenu. Si je fais print list 1, on voit que le contenu de ma liste a été modifié. Puisqu'une list final a son contenu qui n'est pas final. Par contre, une list const a son contenu qui est const. Ce qui veut dire par là, que je ne peux pas faire list 2 et modifier le contenu. Nous avons donc vu dans cette vidéo, les deux mots-clés « final » et « const », leurs ressemblances, mais surtout leurs différences.

### Découvrir l'asynchronicité

Je vous propose de découvrir comment gérer du code asynchrone. J'ai préalablement préparé du code qui est assez simple où j'affiche le message début du code, j'ai ensuite l'appel d'une fonction add qui permet d'additionner deux nombres donc ici 2 + 2. Le résultat sera stocké dans une variable res que j'affiche ensuite et je termine par afficher le message fin du code. Si j'exécute, je devrais avoir début du code 2 + 2 = 4 et le message fin du code. À présent, nous allons réécrire cette fonction-là en simulant une longue opération. Admettons que le calcul se fait sur un serveur et qu'il faille à peu près cinq secondes pour obtenir le résultat. Donc, je prends int a, int b et cette fois-ci, je vais mettre ma durée : duration, je précise que je prendrai cinq secondes. Et j'appellerai Future.delayed. Là, je vais m'arrêter juste pour préciser ce qu'est un Future. Un Future va être utilisé pour représenter une potentielle valeur, même une erreur et cette valeur sera disponible, non pas immédiatement, mais dans le futur. delayed va prendre deux paramètres : la durée et ce qu'on appelle un « callback », une fonction qui sera appelée une fois que le délai sera écoulé. J'utiliserai une fonction anonyme, une fonction anonyme, c'est tout simplement une fonction qui n'a pas de nom. Ici, on retrouve les parenthèses pour les paramètres et le corps de la fonction entre accolades. Une fois que les cinq secondes seront écoulées, j'afficherai un message : fin des 5 secondes. Et enfin, je retournerai mon addition. Je vais modifier l'appel et exécuter le nouveau code. On a le début du code, quatre, fin du code et ensuite, on a la fin des cinq secondes, ça ne correspond pas à ce que l'on souhaite puisque nous, nous voulons que le résultat de l'addition se fasse après cinq secondes. Je vais donc ajouter le mot-clé « await » qui va permettre d'indiquer que le compilateur doit attendre la fin de cette instruction avant de passer à la ligne suivante. Le fait d'utiliser await me pousse à utiliser le mot-clé « async » qui doit être mis juste avant le corps de la fonction. Enfin, Dart me met un message d'erreur puisque je dois préciser que je ne retourne pas un entier immédiatement, mais un entier dans l'avenir, donc en utilisant un Future. Si je ré-exécute mon code, j'aurai donc début du code, instance d'un Future, la fin du code et la fin des cinq secondes. En gros, ce qui s'est passé, c'est que j'ai récupéré immédiatement un Future dont je sais que la valeur soit un entier, j'ai la fin du code qui s'est exécutée, mais la valeur retournée sera perdue. Pour la récupérer, j'ai deux façons de faire : soit de manière asynchrone, en mettant res.then pour déballer mon Future qui prendra là aussi une fonction anonyme. Cette fonction prendra un paramètre qui sera le résultat de mon addition et que j'afficherai, donc je peux mettre print value. Si je ré-exécute, j'ai donc le début du code, à nouveau à cause de ce print res, l'instance du Future, mais cette fois-ci, une fois les cinq secondes passées, j'ai bien le résultat. Si je souhaitais avoir un résultat de manière séquentielle, je pourrais mettre ce code-là en commentaire et à nouveau, faire appel à await, et mettre la fonction main en async en exécutant ; j'ai donc le début du code et cinq secondes qui doivent s'écouler, et j'ai enfin le résultat et la fin du code. Nous avons ainsi vu ce que sont les Future, comment utiliser les mots-clés « await » et « async ».

## Procéder à l'installation du SDK Flutter

### Installer le SDK sur Windows

Dans cette vidéo, nous allons voir comment installer le SDK Flutter sur Windows. Pour cela, nous allons aller sur le site officiel « flutter.dev » et cliquer sur Get started. Il faudra ici sélectionner, bien évidemment, la plate-forme Windows et sur la nouvelle page, on aura toutes les informations permettant l'installation du SDK. Il faudra veiller au préalable à avoir suffisamment d'espace disque et d'avoir les deux outils suivants : Windows PowerShell 5 ou version plus récente, ce qui est déjà le cas sur Windows 10 et Git pour Windows. Git est ce qu'on appelle un système de contrôle de versions qui va, dans le cas présent, nous permettre de pouvoir mettre à jour Flutter, ou encore pouvoir tester les versions beta qui sont proposées. Si vous souhaitez en savoir plus sur cet outil, je vous invite à consulter le catalogue de LinkedIn Learning. Pour savoir si Git est installé sur votre machine, il va falloir ouvrir une invite de commande. Vous allez faire une recherche sur les trois lettres cmd, et valider. Ici, vous aurez ce que l'on appelle un terminal et vous taperez la commande git. Si, comme moi, la commande n'est pas reconnue, c'est que Git n'est pas installé. Pour remédier à cela, vous allez retourner sur le site officiel et cliquer sur Git for Windows. Dans cette nouvelle page, vous sélectionnerez le bon exécutable en fonction de l'architecture de votre machine. Une fois le fichier téléchargé, vous allez l'installer de manière classique. Alors, je vais aller dans mon répertoire de téléchargement et double cliquer sur l'exécutable. Je vais accepter tous les paramètres par défaut. Bien évidemment, vous pouvez customiser à votre bon vouloir. Une fois le téléchargement terminé, il faudra veiller à bien refermer la précédente invite de commande. Je vais donc la clôturer et ouvrir une nouvelle invite. En effet, sur la précédente, les modifications n'ont pas été prises en considération. Je vais maintenant taper git et notre commande est à présent reconnue. On va continuer avec l'installation du SDK Flutter. Je vais retourner sur le site officiel, donc, je reviens en arrière, et je vais à présent descendre jusqu'au bouton flutter_windows. Ce bouton nous permettra de télécharger un fichier zip contenant la dernière version stable du SDK Flutter. Une fois le fichier zip téléchargé et dézippé, vous serez en présence d'un répertoire flutter. Vous pourrez installer celui-ci sur votre disque dur. Il est recommandé de l'installer à la racine. C'est ce que j'ai fait. Maintenant, si j'ouvre à nouveau mon terminal et que je tape flutter, la commande est malheureusement non reconnue. On va faire en sorte que cette commande le soit à présent. Pour ce faire, je vais retourner sur mon explorateur de fichiers, sélectionner mon répertoire flutter, puis mon répertoire bin. Je vais copier le chemin. Maintenant, je vais faire une recherche sur les variables d'environnement et je vais sélectionner Modifier les variables d'environnement système. À présent, je cliquerai sur le bouton Variables d'environnement, je sélectionnerai la variable Path et je cliquerai sur le bouton Modifier. J'ai un ancien flutter que je vais supprimer, mais je pourrais en créer un nouveau et je collerai le chemin que j'ai copié précédemment. Je validerai en cliquant sur OK et je fermerai toutes les autres fenêtres. À présent, je vais à nouveau fermer mon précédent terminal et en ouvrir un nouveau. Si je tape la commande flutter, celle-ci est maintenant reconnue. Nous avons ainsi vu comment installer le SDK flutter et comment installer Git.

### Installer Android Studio sur Windows

Une fois le SDK Flutter installé, nous allons ouvrir un nouveau terminal et taper la commande « flutter doctor ». Cette commande va veiller à ce que tous les outils nécessaires à l'utilisation de Flutter soient bien installés. En effet, nous voyons ici en rouge que le SDK Flutter n'a pas été détecté. On peut l'installer par le biais d'Android Studio et on va d'ailleurs copier l'adresse qui nous est proposée et ouvrir un navigateur web. Je vais copier-coller l'adresse. Il me suffira à présent de cliquer sur le bouton Download Android Studio. Une fois le téléchargement terminé, vous serez en présence d'un fichier d'installation que l'on va lancer. Je vais accepter et je vais accepter tous les paramètres par défaut. Ensuite, je cliquerai sur Next et je laisserai Start Android Studio. Il me suffira de l'afficher, je laisse tel quel. Sur cette nouvelle fenêtre, je cliquerai sur Next, je prendrai une installation de type standard, je prendrai un thème soit sombre, soit clair ; pour ma part, je laisserai clair et enfin, j'accepterai tous les composants qui doivent être téléchargés. Une fois tous les composants téléchargés, je peux cliquer sur Finish. Ici, j'ai la fenêtre de bienvenue d'Android Studio. Je vais cliquer sur Configure et sélectionner Plugins. Dans cette nouvelle fenêtre, je vais taper « Flutter ». Je pourrai ainsi cliquer sur le bouton Install, je vais accepter et il me sera également proposé d'installer le plugin Dart. Je vais là aussi accepter. Quand l'installation est terminée, je serai invité à redémarrer Android Studio pour appliquer les changements. Je vais retourner sur l'invite de commandes et je vais maintenant taper « flutter doctor ». On voit à présent que le SDK Android, par rapport à tout à l'heure, a été installé. Il y a parfois un bug qui apparaît, à savoir que même si on a installé les plugins Flutter et Dart, ceux-ci ne sont pas détectés par Flutter Doctor. Le plus important est que l'on ait les plugins qui s'affichent, du moins qu'à l'invite, que dans la fenêtre de bienvenue d'Android Studio, on ait cette ligne Create New Flutter Project, donc la possibilité de créer un nouveau projet Flutter. Cela signifie que les plugins ont bien été installés. Un dernier point qui est intéressant est qu'il faut accepter les licences Android. Pour ce faire, on va copier la ligne de commande suivante et la coller. Il suffit de valider et ici, je devrai accepter les différentes licences en appuyant sur « Y » pour « Yes ». Si je relance Flutter Doctor, à présent, tous les outils nécessaires pour pouvoir développer sur Flutter ont été installés. Dans cette vidéo, nous avons vu comment installer Android Studio, le SDK Android, comment utiliser Flutter Doctor et enfin, comment installer les plugins Flutter et Dart.

### Installer le SDK sur macOS

Dans cette nouvelle vidéo, nous allons voir comment installer le SDK Flutter sur macOS. Pour cela, je vous invite à aller sur le site officiel Flutter.dev et cliquer sur Get started. Ici, nous sélectionnerons bien évidemment macOS et nous aurons une page nous donnant toutes les informations pour pouvoir installer le SDK. Il faudra bien veiller au préalable à avoir suffisamment d'espace disque disponible et aussi tous les outils qui sont listés ici. Vous cliquerez ensuite sur le bouton flutter_macos, qui vous chargera un fichier zip contenant la dernière version stable du SDK Flutter et une fois le fichier téléchargé et dézippé, vous obtiendrez un répertoire Flutter. Vous pourrez ensuite le déplacer dans le répertoire de votre choix. Pour ma part, je l'ai mis en tant que sous-répertoire du répertoire SDK. Vous ouvrirez ensuite un nouveau terminal. Pour ce faire, vous pouvez cliquer sur la recherche Spotlight et taper « terminal ». Dans la nouvelle console, vous taperez la commande Flutter. On voit ici que la commande n'est pas reconnue. L'objectif à présent est de faire en sorte qu'elle le soit. Nous allons à présent revenir sur le site officiel et on va descendre jusqu'à la partie qui s'appelle « Update your path ». La ligne qui nous intéressera sera celle-ci, qui se décompose en deux parties : donc, un export du path et le chemin jusqu'à notre sous-répertoire bin, qui est inclus dans le répertoire flutter. Je vais donc copier la première partie et retourner sur le terminal. Je vais copier cette partie-là et je vais à présent devoir indiquer le chemin jusqu'au sous-répertoire bin. Pour ce faire, je vais aller dans le Finder, cliquer sur Flutter et faire un clic droit sur le répertoire bin. Ici, je cliquerai sur Copier « bin ». Je retourne sur le terminal et colle ce que j'ai copié. Je veillerai bien au préalable à supprimer l'espace qui a été ajouté et à rajouter un double guillemet. Je valide à présent en appuyant sur la touche Entrée. Si je tape maintenant la commande Flutter, celle-ci est bien reconnue. Il est possible que, tout comme moi, vous utilisiez le shell Zsh. Dans ce cas-là, si vous fermez le terminal et qu'à nouveau, vous ouvriez une nouvelle fenêtre, en tapant Flutter, la commande n'est plus reconnue. Pour pallier à cela, il va falloir recopier la ligne précédente ; je vais donc la sélectionner et la copier, je vais la supprimer. Vous allez taper « vim $HOME/.zshrc ». Ici, vous appuierez sur la touche « I » de votre clavier pour passer en mode insertion et vous ferez Cmd + V pour copier ce que vous avez copié. Enfin, vous terminerez en appuyant sur la touche Echap, « : » et vous terminerez en tapant « wq » qui apparaît en bas de l'écran. Vous validerez en appuyant sur Entrée. À présent, si je relance le terminal, je vais quitter, relancer une nouvelle fenêtre et si je tape « flutter », ma commande est maintenant reconnue. Nous avons ainsi vu comment installer le SDK Flutter sur macOS.

### Installer Android Studio et Xcode sur macOS

Dans cette vidéo, nous allons voir comment installer les différents outils nécessaires à l'utilisation du SDK Flutter sur MacOS. On va commencer par ouvrir un terminal et on tapera la commande flutter doctor. Cette commande va veiller à ce que tous les outils nécessaires à l'utilisation de Flutter sont bien installés. En effet, nous voyons ici en rouge que, par exemple, les éléments permettant de développer sur Android ne sont pas présents. Ainsi, le SDK Android n'a pas été détecté. On peut l'installer par le biais de Android Studio qui est l'environnement de développement pour Android, et on nous propose une adresse que l'on va copier et on va ouvrir le lien dans un navigateur web. On pourra ainsi télécharger en cliquant sur Download Android Studio, l'IDE. C'est ce que je vous invite à faire, et une fois le téléchargement terminé, vous aurez un fichier d'installation. Je vais donc l'ouvrir. Il suffira de déplacer Android Studio vers le répertoire Applications. Une fois le déplacement d'Android Studio terminé, nous fermerons cette fenêtre et nous pourrons utiliser Android Studio. Je vais donc faire une recherche sur Android Studio et l'ouvrir. Je vais bien évidemment accepter l'ouverture du fichier et j'aurais maintenant une nouvelle fenêtre. Ici, je vais accepter de ne pas importer les paramètres par défaut dans le sens où je n'avais pas au préalable déjà Android Studio d'installé. Dans cette nouvelle fenêtre, je vais ainsi pouvoir configurer Android Studio. Je vais accepter une installation de type Standard. Je pourrais choisir soit un thème sombre ou un thème clair. Je laisse le thème par défaut. Et enfin, ici, j'aurai la liste des différents éléments qui vont être téléchargés. Je terminerai en cliquant sur Finish. Ici, je devrais saisir le mot de passe pour accepter l'installation. Une fois les composants téléchargés et installés, il ne me reste plus qu'à cliquer sur Finish. Sur la fenêtre de bienvenue d'Android Studio, je viendrai cliquer ensuite sur Configure et je sélectionnerai l'option Plugins. Je saisirai flutter et je cliquerai sur Install. J'accepte les termes d'utilisation. Il me sera également demandé d'installer le plugin Dart, chose que j'accepterai. Et enfin, il ne me restera plus qu'à relancer Android Studio. Il faut savoir que les deux plugins que nous venons de télécharger sont utiles dans le cas où vous souhaiteriez développer avec Android Studio. On va revenir sur la console et taper à nouveau flutter doctor. On voit qu'à présent, le SDK Android a été détecté. Il faut néanmoins accepter les licences Android. Je vais donc copier la commande suivante et l'exécuter. Ici, il me suffira d'accepter en appuyant sur y pour yes. Et à présent, en relançant flutter doctor, on voit que toute la partie en rapport avec Android a été correctement installée. Juste une précision, ici, il m'est indiqué que les plugin Flutter et Dart n'ont pas été installés, il s'agit d'un bug. Le plus important est que si l'on retourne sur Android Studio, on ait bien créé New Flutter Project, ce qui signifie que les plugins ont bien été installés. Maintenant, on va s'intéresser à la partie Xcode. Il va donc falloir au préalable installer Xcode. Le plus simple est d'aller le télécharger sur l'App Store. Je vais donc lancer l'App Store, je ferai une recherche sur Xcode. Et il me suffira de le télécharger. Une fois le téléchargement terminé, nous retournerons sur la console. Je vais nettoyer l'écran avec la commande clear et on retapera « flutter doctor ». Le premier message que l'on voit ici est que je dois accepter les licences de Xcode. D'ailleurs, c'est rappelé ici, « open Xcode or run the command ». Je vais lancer la commande qui est conseillée. Je tape mon mot de passe d'utilisateur. J'appuie sur la touche Espace pour faire défiler toutes les conditions d'utilisation et je finirai en tapant « agree ». Je vais à nouveau pour relancer la commande flutter doctor. On voit ici qu'il ne me reste plus qu'une seule chose, à savoir exécuter cette commande pour pouvoir installer CocoaPods. Si je lance à nouveau flutter doctor, il a eu un souci avec CocoaPods. Pour résoudre ce problème, on va essayer de définir directement une version. Ce n'est pas un problème qui arrive tout le temps. Et si vous avez le même message d'erreur que moi, vous allez essayer de retaper la même commande en rajoutant la version de CocoaPods. Ici, j'utiliserai la 1.8.4. À présent, je vais refaire un flutter doctor, et à présent, tout fonctionne correctement. Dans cette vidéo, nous avons ainsi vu comment installer les outils pour pouvoir développer sur Android ainsi que les différents outils pour pouvoir développer sur iOS.

### Installer et configurer VS Code

Nous allons installer Visual Studio Code et le configurer afin de le faire fonctionner avec Flutter. Visual Studio Code est un éditeur de code gratuit et open source qui n'est pas uniquement destiné à Flutter, mais qui se veut plutôt généraliste. Il propose de nombreux plugins lui permettant d'être personnalisé et qui peuvent par ailleurs lui ajouter des fonctionnalités dont il serait dépourvu. Je vais taper « visual studio code » et sélectionner le site officiel. De là, je vais cliquer sur Download et en fonction de ma configuration, je choisirai Windows, Linux ou Mac. Une fois le téléchargement fait, il restera plus qu'à procéder à une installation classique, pour ensuite lancer Visual Studio Code. Sur l'écran principal qui s'affiche, je vais pouvoir venir sur la gauche et sélectionner l'icône Extensions. De là, je pourrai chercher et installer des extensions, donc des plugins. Je vais par exemple rajouter un plugin qui va me permettre de franciser Visual Studio Code. Je tape « French » et sélectionne le plugin proposé par Microsoft. Il me reste plus qu'à l'installer et enfin, cliquer sur Restart now, pour que Visual Studio Code redémarre et prenne en considération les modifications. De là, je vois que le menu est traduit en français, ainsi que les sous-menus. Je vais à présent rajouter l'extension Flutter et installer. Je vais vérifier que l'extension Dart a bien été installée, ce qui est le cas, puisque je peux le désinstaller et le désactiver. Dans la suite de cette formation, nous ferons le choix d'utiliser Visual Studio Code pour développer nos applications Flutter.

### Créer un émulateur Android

Nous allons voir comment créer un émulateur Android à partir de l'IDE Android Studio. Une fois que vous aurez lancé Android Studio, vous aurez cette fenêtre de bienvenue ; il vous suffira de cliquer sur Configure. Dans le menu déroulant, vous sélectionnerez l'option AVD Manager et vous aurez ainsi une fenêtre listant des différents émulateurs Android que vous avez d'installés sur votre ordinateur. Ici, j'en ai deux. J'aurai également tout un ensemble d'informations telles que le nom, la résolution, la version d'Android qui est installée sur mon émulateur ou encore la taille qu'occupe mon émulateur sur le disque. Enfin, je pourrai lancer mon émulateur, je pourrai l'éditer pour en changer ne serait-ce que le nom ou la version de l'API et en cliquant sur ce bouton, j'aurai un menu déroulant qui s'affichera, à partir duquel je pourrai dupliquer mon émulateur, donc le copier, je pourrai l'effacer avec le Wipe Data, pour revenir à sa version initiale ou encore, pourquoi pas, le supprimer. Nous allons créer notre propre émulateur. Pour ce faire, on cliquera sur le bouton Create Virtual Device. Dans cette nouvelle fenêtre, j'aurai la possibilité de choisir la catégorie : soit une télévision, soit un téléphone, une montre, une tablette ou encore, utiliser Android Auto. Je vais rester sur le téléphone, pour lequel j'aurai une liste de différents téléphones que je peux utiliser. Pour la plupart, ce sont des téléphones qui ont été produits par Google, donc on a tous les Pixels, on a également les précédentes versions, les versions Nexus, mais on a aussi des versions génériques. J'utiliserai plutôt le Pixel 4 XL, ensuite, j'irai sur Next, j'aurai la possibilité, dans cette nouvelle fenêtre, d'installer une version d'Android. Si je ne l'ai pas, je pourrai également au préalable la télécharger, ensuite, je cliquerai à nouveau sur le bouton Next et enfin ici, j'aurai la possibilité de configurer mon émulateur en donnant un nom ou par exemple l'orientation, lorsque mon émulateur sera lancé. Je pourrai soit sélectionner le mode Portrait qui est le mode par défaut, mais je pourrai tout aussi bien mettre le mode Landscape qui est le mode Paysage. Une fois ma configuration terminée, je cliquerai sur Finish. Et nous avons ainsi notre émulateur qui est créé ; reste plus qu'à l'utiliser dans nos développements en Flutter.


### Installer un simulateur iOS

Nous allons voir comment créer un simulateur iOS. Avant d'aller plus loin, je souhaite préciser la différence principale entre un émulateur et un simulateur. Un émulateur tel que celui que l'on a sur Android va imiter toute la partie logiciel, mais également la partie matériel. De l'autre côté, un simulateur comme pour iOS va seulement imiter la partie logiciel. Maintenant, on va cliquer sur le bouton permettant de faire une recherche. J'aurais pu utiliser le raccourci Cmd + Espace. Ici, nous allons saisir « simulator ». Dans le menu qui apparaît en haut de l'écran, je sélectionnerai File > New Simulator. Dans cette nouvelle fenêtre, je vais pouvoir saisir un nom, admettons, « Simulateur iOS Flutter », je pourrai sélectionner un appareil ; je vais mettre l'iPhone 12 Pro et enfin, je pourrai définir quelle version d'iOS je veux que ce simulateur ait. Ici, je mettrai iOS 14.2. Je terminerai en cliquant sur Create. Pour voir si mon simulateur a bien été créé, je vais retourner au niveau du menu, je vais cliquer sur File > Open, je vais sélectionner la version d'iOS, donc la 14.2 et ici, je trouverai mon simulateur iOS Flutter. Si je clique dessus, j'ai ainsi mon simulateur iOS qui a été créé. Nous avons ainsi vu, dans cette vidéo, comment créer un simulateur iOS.

## Utiliser Flutter

### Créer un nouveau projet

Regardons comment créer un nouveau projet Flutter de trois façons différentes. Nous commencerons par l'utilisation d'Android Studio, puis comment faire la même chose avec un Visual Studio Code, et enfin, nous terminerons en créant un nouveau projet uniquement par le biais de lignes de commandes. On va donc lancer Android Studio. Dans la fenêtre de bienvenue, nous sélectionnerons Create New Flutter Project. Sur cette nouvelle fenêtre, on laissera Flutter Application sélectionnée. Ensuite, il faudra configurer notre nouvelle application. Au niveau du nom du projet, il faut garder à l'esprit qu'on ne peut pas utiliser ni d'espace ni de majuscule. Ainsi, je ne peux pas faire Myflutter_app. On voit qu'en dessous, j'ai un message d'erreur qui me l'indique. Je dois tout laisser en minuscule et si je souhaite utiliser un espace, puisque je ne peux pas, ça aussi, l'utiliser, je devrais mettre un underscore. Ainsi, si je veux mettre my flutter_app, je devrais remplacer l'espace par un underscore. Le second champ concernera le chemin vers le SDK Flutter. Donc, il faudra mettre le bon chemin. Ensuite, il faudra préciser l'endroit où sera enregistré votre projet Flutter. Si vous voulez le modifier, il suffira de cliquer sur cette icône-là, de sélectionner le bon répertoire, et enfin, vous cliquerez sur Open. Vous terminez avec la description de votre application Flutter. On cliquera ensuite sur Next. Ici, il faudra définir le nom du package. Ce nom doit être fait de manière à ce qu'il soit en notation inversée du nom de domaine. Cela permettra d'identifier votre application de manière unique sur le Play Store via le package name ou sur l'App Store grâce au Bundle Identifier. On laissera ensuite le support des langages Kotlin et Swift et on cliquera sur Finish. Notre projet se génère et vous pourrez ainsi commencer à développer sur Flutter. On va à présent voir la même chose pour Visual Studio Code. Donc, je vais fermer le projet et je vais lancer Visual Studio Code. Dans cette fenêtre, il faudra aller au niveau du menu de tout en haut et cliquer sur Affichage > Palette de commandes. Ici, vous taperez flutter et vous sélectionnerez Flutter:New Project. Il faudra à nouveau donner le nom de votre projet. Donc, admettons, je vais mettre my_flutter_app_vscode et j'appuierai sur la touche Entrée. Ici, je sélectionnerai le répertoire où je veux enregistrer mon projet puis je cliquerai sur le bouton bleu Select a folder to create the project in. Notre projet est en train de se générer. Et vous pouvez à présent commencer à développer en Flutter. Une précision néanmoins, si vous souhaitez modifier ne serait-ce que le nom du package ou le langage à utiliser, il faudra aller sur Code. Si vous êtes sous Windows, il faudra sélectionner Fichier à la place, puis Préférences et enfin, Paramètres. Vous saisirez ensuite flutter et vous aurez tout un panel d'options qui vous permettront de personnaliser votre projet. Vous pourrez ainsi descendre et sélectionner le langage de programmation que vous souhaitez pour Android, Kotlin ou Java ou encore pour iOS, Swift ou Objective-C. Vous pourrez également définir le package de l'organisation. Donc, vous cliquerez sur Modifier dans settings.json, et ici, vous pourrez laisser, par exemple, « com.myorg. ». Terminons à présent la création d'un projet en mode console. Je vous invite déjà à aller directement sur le répertoire où vous voulez créer votre projet. Pour moi, ce sera Documents, ensuite, Developpement/projects/ et j'appuierai sur la touche Entrée. Ici, je taperai flutter create, le nom de mon projet, alors, je mettrai my_flutter_app et je mettrai tout simplement commands et je validerai en appuyant sur la touche Entrée. Ici, mon projet va être généré. Si je souhaite néanmoins, comme ce qu'on a vu avec Visual Studio Code ou même Android Studio, le peaufiner en ajoutant d'autres informations, je pourrais, par exemple, faire flutter create -i, pour iOS, et définir le langage. Admettons, si je veux de l'Objective-C, je ferais objc. Si je veux ajouter un langage pour Android et dire que je souhaite utiliser du Java, je mettrais -a java. Vous pouvez obtenir toutes les possibilités, toutes les options que l'on peut utiliser avec flutter create, en tapant directement flutter create -h ou encore, --help. Et vous aurez ainsi toutes les options qui sont disponibles. Nous avons ainsi vu trois façons différentes de pouvoir générer un nouveau projet Flutter.

### Comprendre la structure d'un projet

Dans cette vidéo, nous allons voir la structure d'un projet Flutter. Dans la suite de cette formation, je vais utiliser Visual Studio Code. Ainsi, je vais commencer par le lancer. Sur la fenêtre de bienvenue, je vais pouvoir ouvrir mon projet. Je vais donc sélectionner Ouvrir un dossier et sélectionner un projet que nous avons précédemment créé. J'aurais pu faire la même chose en cliquant sur Fichier > Ouvrir. Je vais maintenant cliquer sur l'icône Explorateur de fichiers où j'aurais l'arborescence de mon projet. Avant d'aller plus loin, nous allons améliorer la visibilité de notre projet. Je vous propose donc de cliquer sur l'icône Extensions et de faire une recherche sur icons. Vous allez cliquer ensuite sur Installer au niveau de vscode-icons. Une fois le téléchargement terminé, cliquez sur Définir le thème des icônes de fichier. Ici, si je reviens sur l'explorateur, je constaterai que nous avons des icônes qui ont été ajoutées, ce qui permet de plus facilement identifier les différentes parties de notre projet. On va commencer par les deux premiers répertoires qui sont des répertoires de configuration, l'un pour dart et le second pour idea. idea étant tout simplement Android Studio. Une partie qui va être intéressante va être le répertoire Android et iOS, puisque chacun des répertoires va contenir pour l'un un projet Android et pour l'autre, un projet iOS. Ces deux répertoires vont nous permettre de pouvoir les personnaliser. Par exemple, pour Android, ajouter des permissions ou pour iOS, de pouvoir compiler notre projet via Xcode. Un répertoire qui est très intéressant sous Flutter va être le répertoire lib puisque celui-ci va contenir toute la structure de notre application Flutter. Nous allons ainsi pouvoir y créer des fichiers en dart. Nous allons pouvoir créer des sous-répertoires pour structurer notre application. Et enfin, il y a un dernier répertoire qui est le répertoire test. Celui-ci dépasse le cadre de ce projet puisqu'il va nous permettre d'écrire des tests, que ce soient des tests unitaires ou des tests d'intégration sur notre application. Enfin, je voudrais terminer avec le fichier pubspec.yaml qui va contenir des informations sur notre application. Ainsi, nous aurons le nom de l'application, la description, la version, mais on pourra également ajouter des dépendances à notre projet en utilisant ce que l'on appelle des packages qui vont venir étendre les possibilités de notre application. Et enfin, on pourra y ajouter des assets tels que des images ou des polices de caractères. Nous avons ainsi vu quelle est la structure d'un projet Flutter, quelles sont les différentes parties qui la composent et surtout, les parties qui vont nous intéresser pour du développement d'applications avec Flutter.

### Appréhender la notion de widget

Nous allons aborder une notion importante en Flutter qui est celle des widgets. Je rappelle que Flutter est un toolkit orienté UI pour User Interface. Ainsi, les widgets vont être une notion importante puisqu'ils vont permettre de créer une interface utilisateur. Sachant qu'une phrase que vous verrez souvent associée à Flutter est que tout est widget. En effet, un widget peut représenter un espace, un alignement, la détection d'un clic ou encore une vue. Pour ceux qui ont déjà développé en natif sur Android ou iOS, il faudra bien veiller à ne pas penser qu'un widget est uniquement une View pour Android ou une UIView pour iOS. Par ailleurs, les widgets peuvent s'imbriquer et contenir un ou plusieurs autres wigets, ce qui m'amène à la philosophie derrière les widgets, qui est d'utiliser autant que possible la notion de composition à la place de l'héritage. En d'autres termes, si vous souhaitez, par exemple, créer votre propre bouton, vous n'allez pas le créer en héritant d'une classe bouton mais vous allez plutôt le créer à partir d'autres widgets. Maintenant que nous en savons un peu plus sur les widgets, nous allons voir une notion qui est souvent utilisée en Flutter et qui s'appelle l'arbre de widgets. ou l'arborescence des widgets, ou encore, dans sa version originale, widget tree. Comme dit précédemment, un widget peut en contenir d'autres. On va ainsi représenter cela sous forme d'arborescence, sachant qu'un widget qu'on appellera parent va pouvoir contenir un widget ou une liste de widgets. Le widget enfant, quant à lui, sera contenu par un autre widget. Si on prend l'écran suivant qui est tiré du projet de base d'une application Flutter, on aurait cette arborescence où l'on voit qu'un widget peut avoir plusieurs widget. Si pour chaque widget, on affiche son vrai nom, l'arbre devient comme suit. On voit ainsi que le widget qui s'appelle Center n'a qu'un seul enfant. Tandis que en dessous, celui qui s'appelle Column a pour sa part plusieurs enfants. Pour mieux comprendre l'arbre des widgets, on va représenter l'arborescence précédente sous une autre forme où les widgets parents contiennent les widgets enfants. Pour alléger le schéma, on va supprimer les widgets qui ne sont pas directement visibles sur l'écran. Ici, le widget Scaffold va contenir tout notre écran et chaque partie de l'application, que ce soit la barre de titre en haut, le texte avec le compteur au centre, ou encore le bouton en bas à droite, se présentera sous forme de widget pouvant contenir ou non d'autres widgets. Pour en revenir au début de cette vidéo, je disais que tout est widget, on voit bien que pour obtenir le texte du milieu, on va utiliser un widget qui va centrer ses enfants. Pour avoir deux zones de texte disposées verticalement, on utilisera le widget Column. Nous avons ainsi vu une notion essentielle en Flutter, à savoir les widgets et comment ils peuvent se composer.

## Créer une interface utilisateur avec Flutter

### Employer les widgets MaterialApp, CupertinoApp et Text

Nous allons utiliser nos premiers widgets en Flutter. J'ai créé un projet que j'ai appelé flutter_basics, vous pouvez le nommer différemment, bien évidemment, et une fois votre projet généré, vous veillerez bien à afficher l'explorateur de fichiers. Vous sélectionnerez ensuite le répertoire lib pour terminer par la sélection du fichier main.dart. Ici, nous allons sélectionner tout ce qui est en dehors de la fonction main pour le supprimer, et on veillera bien évidemment à supprimer MyApp. Je rappelle que la fonction main est le seul point d'entrée de toute application Dart, et par extension, de toute application Flutter. runApp, quant à lui, permet de lancer notre application en prenant en paramètre un widget. Le premier widget que nous allons utiliser va permettre de définir le design global de notre application. Nous pouvons ainsi utiliser soit le widget MaterialApp ou encore le widget CupertinoApp. Le premier va respecter les principes définis par le material design, tandis que CupertinoApp va suivre les recommandations d'Apple quant à la construction d'une interface utilisateur Ainsi, MaterialApp sera plutôt destiné à des applications universelles pouvant tourner sur Android, iOS ou encore sur le web. CupertinoApp, lui, servira des applications qui auront plutôt tendance à ne fonctionner que sur iOS, bien que cela ne vous empêche pas d'utiliser CupertinoApp sur Android. Je vais ainsi passer en paramètre MaterialApp, qui est un widget, et qui possède une propriété qui s'appelle home. home va prendre lui-même en paramètre un widget et je vais passer le widget Texte qui me permettra d'afficher du texte sur mon écran. Je mettrai Hello World. Il est recommandé d'utiliser une virgule à la fin de chaque widget. Si je fais un clic droit et que je clique sur Mettre le document en forme, mon code se mettra sur une seule ligne, tandis que si je suis les recommandations en mettant une virgule, je mets une première et une seconde virgule, je fais à nouveau un clic droit et je clique sur Mettre le document en forme, mon code est alors formaté et devient beaucoup plus lisible. Je vais à présent sauvegarder notre code en faisant Cmd + S sur Mac ou Ctrl + S sous Windows. Pour exécuter mon application, je pourrais soit cliquer sur ce bouton qui est en haut à droite, soit aller sur le menu et cliquer sur Exécuter, puis Exécuter sans débogage. Ou enfin, je peux directement cliquer sur run. Ici, mon émulateur va se lancer. Je vais l'afficher. Et nous avons le résultat produit par notre application. Nous avons bien « Hello World ». Si je souhaite customiser le texte, celui-ci prend également des paramètres. Il a quelques propriétés. Ainsi, je peux rajouter grâce à la propriété style un TextStyle qui va me permettre de modifier, par exemple, la couleur du texte, l'arrière plan... Je pourrais aussi agrandir la police. Je vais, par exemple, mettre un backgroundColor qui permettra de modifier la couleur d'arrière-plan. Pour définir une couleur, je mettrai Colors avec un s, suivi du nom de ma couleur. Je mettrai blue. Et je changerai la taille de la police avec fontSize en passant, admettons 40. Je relance mon code et on voit que la modification a bien eu lieu. Si je souhaite ajouter une nuance, je peux sélectionner blue, et je vois une liste des différentes possibilités. Je vais rajouter un crochet et mettre 50. Je relance. Et on voit bien que l'arrière-plan a été modifié en conséquence. Dans cette vidéo, nous avons vu comment créer une application respectant les principes du material design, comment utiliser un widget Text, et comment le modifier.

### Aborder Scaffold

Nous allons découvrir un widget qui est assez récurrent ; le widget Scaffold. Dans cet exemple, il faut admettre que notre application n'est pas des plus attrayantes. Grâce à Scaffold, nous allons pouvoir améliorer notre interface puisqu'il propose parmi de nombreuses autres choses la possibilité d'ajouter une AppBar qui se logera en haut de l'écran et qui permettra, par exemple, d'afficher un titre. Scaffold nous permettra aussi d'avoir un menu coulissant sur le côté que l'on appelle un drawer, ou encore, pourquoi pas, un floatingActionButton qui est un bouton flottant que l'on trouve la plupart du temps en bas à droite. On va modifier notre application pour y intégrer un Scaffold. Je vais donc copier le texte qui est affichait « Hello World » et le remplacer par le widget Scaffold. On va utiliser la propriété AppBar qui prend un widget AppBar, lui-même prenant une propriété title. On serait tenté ici pour l'AppBar de mettre directement une chaîne de caractères admettons, « MyApp », et si je passe mon curseur sur la propriété title, je vois que celui-ci n'accepte qu'un widget. Je vais donc mettre un widget Text pour pouvoir afficher ma chaîne de caractères. Si je sauvegarde et que je lance mon code, l'application est bien plus jolie à présent. La AppBar qui est ici apparaît bien avec le titre et elle occupe toute la largeur de l'écran. Un thème utilisant la couleur bleue a été utilisé par défaut. Nous allons maintenant utiliser tout l'espace restant qui est ici en blanc en utilisant la propriété body. Je vais coller le texte que j'avais supprimé précédemment et je vais reformater mon code. Je sauvegarde puis je relance l'application. Mon texte s'affichant, je vais à présent ajouter un floatingActionButton. Pour savoir où le placer, je vais m'aider du commentaire qui a été auto-généré, je vois que cette parenthèse fait référence au widget Scaffold. Je vais venir juste au-dessus et taper ensuite floatingActionButton qui prendra un widget FloatingActionButton. Ici, j'ai une mise en garde, un warning. Je vais cliquer sur l'ampoule qui va m'indiquer qu'il faut un argument requis un argument qui est obligatoire. Je vais donc cliquer dessus pour que cela s'ajoute automatiquement. Cet argument est celui qui permet de gérer le clic. C'est pourquoi je vais laisser le corps de la fonction anonyme vide et je vais plutôt ajouter une propriété s'appelle child. Cette propriété m'indique donc qu'un floatingActionButton accepte un seul widget enfant. Je vais donc mettre un texte, et j'ai créé « OK ». Je terminerai par sauvegarder et par relancer mon application. J'ai ainsi mon floatingActionButton qui apparaît avec le texte. Si je clique dessus, il n'y a aucune action puisque j'ai laissé le corps de ma fonction vide, et quand je clique sur le bouton, j'ai une petite animation. C'est ce qu'on appelle l'animation ripple puisque j'ai défini dans mon application que l'on allait utiliser un material app, et donc, suivre les principes du material design. Dans cette vidéo, nous avons ainsi vu ce qu'est un Scaffold et comment l'utiliser dans notre application.

### Tirer parti des stateless widgets et du hot reload

Nous allons voir comment créer un statelessWidget et comment tirer profit du hot reload. Je vais commencer par centrer le texte Hello World qui, actuellement, est en haut à gauche de l'écran. Pour ce faire, je vais utiliser le widget Center. Je vais venir devant le widget Text et taper Center. J'ouvre la parenthèse. Il faudra bien évidemment que je pense à la fermer. Et je vais utiliser la propriété child en disant que le widget enfant du widget Center est ce widget Text. Une autre façon de faire qui est beaucoup plus simple, serait à nouveau de venir sélectionner le widget Text, de cliquer sur l'ampoule qui est sur la gauche et de sélectionner Wrap with Center, envelopper avec le widget Center. Je sauvegarde. Pour que mes modifications soient prises en compte, je vais cliquer sur le bouton Redémarrer. On appelle cela un hot restart. Il est important de retenir qu'il existe globalement deux types de widgets en Flutter. Nous avons les stateless widgets pour widget sans état, et les statefull widgets qui est le contraire donc, widget avec état. Les stateless widget vont être des widgets dont l'état ne changera pas une fois le widget construit. Par exemple, un widget Text comme celui affichant actuellement Hello World ne pourra pas se rafraîchir avec une nouvelle chaîne de caractères une fois qu'il a été construit. À l'inverse, un statefull widget pourra avoir son état changé durant toute sa durée de vie. Un CheckBox en sera un car il peut prendre deux états, coché ou non coché. Pour faire simple, si un utilisateur peut interagir avec le widget, il y a de fortes chances qu'il soit statefull. Sinon, il sera stateless. Les statefull widgets sont vus dans une autre vidéo de cette formation. On va maintenant créer notre premier stateless widget. Grâce à ça, plutôt que de devoir tout mettre dans la fonction main comme c'est actuellement le cas, nous allons pouvoir subdiviser notre code et permettre son éventuelle réutilisation. Mais on pourra aussi tirer bénéfice du hot reload qui nous permettra de répercuter tout changement à notre code sans avoir besoin de redémarrer l'application. Je vais donc écrire sur le Visual Studio Code st, qui m'ouvrira un menu contextuel. Je sélectionnerai ainsi Flutter stateless widget. Je devrais fournir un nom à ma classe. Je mettrai HomePage. Et on voit que finalement, un stateless widget va venir redéfinir une méthode qui s'appelle build, et qui retourne un widget. Cette méthode build sera appelée à chaque fois qu'il y aura une modification au niveau de notre widget. Je vais à présent sélectionner notre scaffold avec toute son arborescence. Je vais couper. Je vais supprimer le widget container que nous verrons dans une autre vidéo de cette formation et je vais enfin coller mon scaffold. Je vais supprimer la virgule puisque je n'ai pas d'autres widgets à ajouter, et vu que nous utilisons le mot clé return, nous devons terminer par un point virgule. À présent, je vais utiliser le nom du widget que je viens de créer HomePage, je vais sauvegarder mes changements, et je vais devoir redémarrer une première fois l'application puisque j'ai fait des modifications à ma fonction main. Et maintenant, si je fais un changement, par exemple sur, Hello World, et que je rajoute un point d'exclamation, Je vais même rajouter deux autres K à OK. Je sauvegarde en faisant Cmd + S sur Mac ou Ctrl + S sur Windows. On voit que immédiatement, mes changements se sont répercutés sur mon émulateur. Je reviens. Je re-modifie mon floatingActionButton et je re-sauvegarde à nouveau, tout se fait de manière immédiate. C'est ce que l'on appelle le hot reload. Dans cette vidéo, nous avons vu comment créer un stateless widget, la différence avec un statefull widget, et enfin, nous avons vu de manière pratique comment utiliser le hot reload.

### Composer des layouts : Container et Stack

Nous allons découvrir deux widgets nous permettant de réaliser nos « layouts » : les widgets Container et Stack. Commençons avec le Container qui comme son nom le laisse penser, va servir de conteneur. Il ne contiendra qu'un seul widget, il aura donc un seul enfant, mais il aura différentes propriétés lui permettant par exemple, de définir une taille ou encore, une couleur d'arrière-plan. Je vais modifier notre widget Text en supprimant Hello World et en tapant Flutter. Je vais également enlever la ligne permettant de définir la couleur d'arrière-plan du texte. Et enfin, je vais terminer en ajoutant un Container widget Text. À présent, je sauvegarde et on voit qu'au-delà du fait d'avoir changé le texte et d'avoir changé la couleur d'arrière-plan, rien n'est apparent. Pour voir la différence, je vais ajouter une nouvelle propriété qui s'appelle « Color » qui permet à un Container d'avoir une couleur d'arrière-plan. Je vais utiliser Colors.lime pour du vert citron et je sauvegarde. On voit que le Container va occuper la taille de son widget enfant. Si je veux que le Container occupe plutôt la taille du widget parent, et donc en l'occurrence ici, ça serait tout l'espace qui est en blanc, je ferais appel à la propriété « width », donc la largeur et je lui passerais comme valeur double.infinity. Je ferai la même chose avec la hauteur : « height » double.infinity, enfin je sauvegarde et on voit que tout l'espace a été occupé par le Container. Enfin, si je souhaite attribuer à mon Container une taille fixe, je pourrai lui mettre par exemple, 300 pour la largeur et 400 pour la hauteur. On voit d'ailleurs que le widget enfant, ici en l'occurrence, c'est le Text, va venir se loger en haut à gauche. Si je souhaite faire en sorte qu'il soit logé au centre, j'utiliserai la propriété Alignement suivi de Alignement avec un A majuscule point center. Je pourrais faire la même chose si je voulais qu'il soit centré, mais plutôt à droite, donc je mettrai center.Right ; ou encore, si je souhaitais qu'il soit en bas à gauche, je mettrai bottomLeft. À présent, regardons de plus près le widget Stack. Celui-ci va contenir plusieurs widgets puisqu'il va venir les empiler les uns sur les autres. Je vais supprimer notre Container et le remplacer par Stack. Une Stack va prendre comme propriété non plus child, mais plutôt children vu qu'il a plusieurs enfants. Et children sera initialisé avec une liste [inaudible] que l'on voit à travers l'utilisation des double crochets. À l'intérieur, je vais créer trois Containers qui auront une forme carrée, donc pour la largeur, je mettrai 250 pour le premier, la hauteur sera bien évidemment la même et je mettrai une couleur d'arrière-plan : Color Colors de couleur noire. Je vais dupliquer cette ligne et la coller deux fois. Je vais modifier les tailles, le second sera légèrement plus petit que le premier, il aura une couleur verte et enfin, le dernier sera le plus petit, et il aura une couleur jaune. Si je relance l'application ou du moins, si je fais du « hot reload », je vois que mes différents Containers sont venus s'empiler les uns sur les autres. Là aussi, si je souhaite modifier l'alignement, je pourrai utiliser la propriété Alignement et faire comme ce qu'on avait fait avec le Container. Ainsi, mes différents Containers sont à présent empilés, mais centrés. Nous avons ainsi vu comment utiliser le widget Container et comment utiliser le widget Stack.

### Composer des layouts : Row et Column

Cette vidéo va vous montrer comment on peut disposer des widgets de manière horizontale ou verticale. Nous allons commencer avec le widget Row. Celui-ci permet de mettre les widgets qu'il contient les uns à la suite des autres de manière horizontale. Je vais modifier le widget Container par le widget Row et je vais lui ajouter des éléments à travers l'utilisation de la propriété children. Les éléments que je vais lui insérer vont être le logo FlutterLogo qui permet d'afficher le logo Flutter. Je vais définir la taille. Et plutôt que de devoir copier x fois le FlutterLogo, je vais utiliser la boucle for. Donc, for i, alors je vais l'afficher cinq fois. Une boucle for, quand on l'utilise dans une liste, ne peut pas contenir d'accolades. Je vais donc les supprimer et afficher cinq fois mon logo Flutter. Je lance mon application et on voit bien ici que j'ai les cinq éléments qui sont disposés de gauche à droite et de manière horizontale. Si je voulais d'ailleurs les mettre de droite à gauche, je pourrais utiliser la propriété textDirection et utiliser ensuite TextDirection.rtl. rtl pour right to left donc, de droite à gauche. Je vais à présent ajouter un Container à notre Row et je vais lui ajouter une couleur, donc color. Je vais mettre Colors.blue avec une nuance à 50. Je relance. Le Container me permet de voir que le Row par défaut va utiliser tout l'espace disponible. Si je souhaite que le Row utilise le moins d'espace possible, je vais utiliser la propriété mainAxisSize, suivie de MainAxisSize.min. D'ailleurs, j'en profite pour aborder la notion de mainAxis. Dans un Row donc, dans une ligne, l'axe principal sera l'axe horizontal. De la même manière pour une colonne qui affiche de manière verticale les éléments, son axe principal sera l'axe vertical. Ainsi, je vais pouvoir utiliser une propriété qui s'appelle mainAxisAlignement. Je pourrais ainsi faire en sorte que les éléments soient centrés, qu'ils soient éventuellement séparés par des espaces. Je peux même demander à ce que l'espace soit réparti de manière équitable. Si je change mon widget Row et que je le remplace par le widget Column, on voit que j'ai la même chose sauf qu'à présent, les éléments sont disposés de manière verticale. Je vais enlever le mainAxisAlignement et les éléments sont ainsi beaucoup plus regroupés. Aussi, si je souhaitais que les différents éléments qui sont contenus soient affichés non pas de haut en bas, mais plutôt de bas en haut, j'utiliserai le verticalDirection suivi de VerticalDirection.up. Enfin, nous avons vu le mainAxis, mais il y a également le crossAxis. Le crossAxis est l'axe perpendiculaire. Ainsi, pour une colonne dont l'axe principal est l'axe vertical, le crossAxis sera l'axe horizontal. Donc, si j'utilise le crossAxisAlignement et que je mets la propriété CrossAxisAlignement.end, pour pouvoir l'afficher puisque le problème étant que là, le crossAxis utilise le moins d'espace possible. Pour agrandir cela, je vais aller sur mon Container et dire qu'il doit occuper tout l'espace disponible. Je vais lui mettre une largeur à l'infini et je ferai pareil pour la hauteur. Il occupera ainsi tout l'écran. Et là, on voit finalement que pour une colonne dans le mainAxis est vertical, le crossAxis me permettra de décaler les éléments sur la droite. Si je souhaite les centrer, je pourrais utiliser center. Si je modifie la colonne par un widget Row, j'obtiendrais la même chose, mais de manière inverse, puisque le crossAxis de widget Row sera l'axe vertical. Nous avons ainsi vu comment utiliser les widgets Row et Column.

### Composer des layouts : Expanded et la propriété Flex

Nous allons voir comment gérer l'espace disponible dans un widget Row ou un widget Colors. J'ai préalablement écrit du code que l'on va passer en revue. J'ai ainsi utilisé un widget Row qui va contenir trois widgets enfants de type Container. Chaque Container aura sa largeur égale à sa hauteur de sorte à avoir une forme carrée. Le premier conteneur aura une couleur jaune, d'ailleurs, on peut le voir ici. Le second, une couleur verte, Le dernier, une couleur indigo. Enfin, j'ai inclus mon widget Row dans un widget Container, à nouveau, qui, lui, aura une couleur plus ou moins bleu pastel, j'ai utilisé une nuance à 50, et cette couleur bleue nous indiquera quelle est l'espace qui n'a pas été utilisé par les trois containers. Pour mieux comprendre cela, je vais lancer le code. On voit ici nos trois containers, et en bleu, on voit tout l'espace qui n'a pas été utilisé. Dans le cas où je voudrais que le container vert utilise tout cet espace restant, je le sélectionnerais, et je le mettrais dans un widget qui s'appelle Expanded et qui a une propriété child. On voit maintenant que le container vert s'est étiré et a occupé tout l'espace disponible restant. Si maintenant je fais la même chose avec les deux autres containers, je leur met donc un Expanded, je pense bien sûr à fermer les parenthèses, on voit que l'espace qui est attribué à notre widget Row est finalement partagé de manière équitable entre les trois containers. Pour mieux comprendre cela, il faut savoir que Expanded va avoir une propriété qui s'appelle flex. Cette propriété, par défaut, va être mise à 1. Si je rajoute la propriété flex aux trois Expanded, on voit que rien ne change par rapport à ce que l'on avait. Maintenant, si je mettrais, on va dire, une valeur de 10 au Container vert, on voit que celui-ci a occupé beaucoup plus d'espace que les autres. Il faut savoir que l'espace total utilisé par le widget Row va être égal à la somme des flex qu'il contient. En d'autres termes, ici, l'espace total disponible est égal à 10 plus 1, plus 1, soit 12. Donc ici, notre second container va prendre 10 douzièmes de l'espace, tandis que les deux autres prendront seulement un douzième de l'espace. Je peux modifier les valeurs flex, et là, en faisant l'addition, on aura donc une valeur totale de 6 : 3 plus 2, plus 1. Le premier occupera un sixième de l'espace, le second, deux sixièmes, soit un tiers de l'espace, et le dernier, trois sixièmes, soit un demi, donc la moitié de l'espace. On le voit ici, la couleur indigo utilise la moitié. Ici, on va dire à peu près 0,33 %, et le dernier, un sixième de l'espace. Une autre façon intéressante d'utiliser les Expanded est avec les textes. Alors, je vais copier le premier container. Je vais supprimer tout le reste et je vais ajouter un texte. Je vais mettre, admettons, « Hello ça va? », et je vais relancer. Tout va bien. Par contre, si mon texte venait à s'agrandir de sorte à ce que j'ai une longue chaîne de caractères, je vais relancer. On voit que là, sur l'écran, j'ai une zone avec des lignes hachurées de couleur jaune et noir. Cela s'appelle un overflow. Mon texte a finalement débordé de l'écran. Pour remédier à cela, je vais venir le mettre dans un Expanded avec la propriété, toujours, child qui est obligatoire. Et si je relance, on voit que le texte, finalement, a adapté son contenu de sorte que le texte est revenu à la ligne. Nous avons ainsi vu l'utilisation du widget Expanded, mais également l'utilisation de sa propriété flex.

### Récupérer les images et les icônes

La plupart des applications utilisent des images et des icônes. Nous allons voir comment les utiliser en Flutter. J'ai ici une application basique où j'ai un Container qui est de couleur bleu pastel et qui est centré au niveau de l'écran. Sa largeur est plus petite que sa hauteur et enfin, en bas à droite, j'ai un FloatingActionButton qui affiche la chaîne de caractères OK. On va modifier ce FloatingActionButton pour obtenir non pas du texte, mais une icône. Je vais supprimer le widget Text et le remplacer par le widget Icon. Ici, on voit que ce widget prend en paramètre ce qu'on appelle un widget « IconData ». Pour en obtenir un, je vais donc mettre Icons avec un S suivi d'un point et ici, j'obtiendrai une liste de différentes icônes que je peux utiliser dans mon application. Pour ma part, j'utiliserai l'icône Add, je sauvegarde et on voit que mon texte OK a été remplacé par une icône en forme de plus. Je peux en outre customiser mon icône, je vais lui mettre une taille de 50 et je vais définir sa couleur comme étant jaune. Si je relance, la couleur a bien été modifiée et la taille est différente. Intéressons-nous maintenant aux images. On va récupérer une image depuis internet. Je vais commencer par dire que mon Container prend un enfant, celui-ci sera un widget de type Image et j'utiliserai le constructeur nommé Network. Ce constructeur va prendre en paramètre une URL, l'URL de l'image. Pour ma part, j'utiliserai le site Lorem Picsum qui va nous retourner une image de manière aléatoire. En paramètre, je dirai que je veux une image dont la largeur est de 640 pixels. Si je lance, j'ai donc bien une image et celle-ci est récupérée depuis internet. Je peux utiliser une propriété qui s'appelle « fit » qui va me permettre de définir les proportions de mon image. Ainsi, je pourrai mettre BoxFit.fit ou pourquoi pas, BoxFit.fitHeight pour adapter à ma hauteur. Regardons maintenant comment on peut utiliser des images, non plus depuis le réseau, mais directement depuis notre application. Je vais aller sur l'explorateur de fichier et à la racine, je vais créer un nouveau répertoire. Je peux l'appeler comme bon me semble. Pour ma part, je l'appellerai « assets », donc un fichier de ressources à l'intérieur duquel je vais créer un sous-répertoire que j'appellerai « images ». Ici, j'ai préparé deux images que je vais glisser-déposer. Il ne me restera maintenant plus qu'à informer mon application que ces deux images sont disponibles. Je vais donc aller sur mon fichier de configuration pubspec.yaml, c'est un fichier où l'indentation est importante. Donc, je devrais mettre assets en dessous de Flutter ; il faut pas qu'il soit au même niveau, il faut qu'il y ait absolument cette indentation. Je vais mettre assets: à l'intérieur duquel je vais définir le chemin jusqu'à mes images. Ça sera donc assets/image/img1 .jpg. Je fais la même chose pour la seconde image. C'est vrai que là, j'ai que deux images, donc je peux les taper manuellement. Mais dans le cas où vous en auriez une trentaine, voire même une quarantaine, vous pouvez définir le répertoire qui les contient. Je peux donc faire assets/images/ et terminer. Alors, il faut bien veiller à avoir le dernier slash. Si je sauvegarde et que maintenant, je reviens sur mon fichier main.darts, je vais pouvoir mettre cet Image.network en commentaire et mettre maintenant Image.assets. En paramètre, je mettrai le chemin de mon image. Donc, je pourrais mettre assets images/ et pourquoi pas, img2 pour les JPG. Si je relance, j'ai bien ma seconde image, on va quand même vérifier. Il s'agit bien de la bonne image. Nous avons ainsi vu comment utiliser des icônes dans une application, mais également, comment récupérer des images depuis internet, comment les adapter et comment également utiliser des images depuis notre application.

### Afficher une liste de widgets grâce à une ListView

Pour pouvoir afficher une liste de widgets et pouvoir la faire défiler verticalement ou horizontalement, Futter nous offre la possibilité d'utiliser le widget ListView. C'est ce que nous allons découvrir dans cette vidéo. Pour illustrer la ListView, nous allons afficher dans notre application, la liste des 27 pays membres de l'Union Européenne. Je vais créer une constante dans ma classe HomePage que j’appellerai « euroList » et qui sera une liste de strings. Cette liste sera le nom des 27 pays. Pour les afficher, je remplacerai mon Container par le widget ListView. Ce widget va utiliser la propriété children qui sera une liste de widgets. Ces widgets n'ont pas à être du même type, je peux en effet avoir un texte vide suivi d'un Flutter logo, je peux encore avoir un Container ; je pense que vous avez compris le concept. Dans notre cas, nous allons afficher les noms des 27 pays. Je vais donc utiliser une boucle for, je vais appeler ma variable « country » et ma liste s'appelle « euroList ». Faudra bien veiller à supprimer les accolades puisqu'on ne peut les utiliser dans le cas présent. Et j'afficherai dans un WidgetText le nom du pays. Si je lance notre application, on a bien la liste des 27 pays que malheureusement, je ne peux faire défiler puisqu'il rentre entièrement dans notre écran. Nous allons remplacer notre texte par le widget ListTile qui offre l'avantage de facilement agrémenter les éléments de la ListView. ListTile. Et en paramètre, on va trouver une propriété Title pour le titre. Je mettrai le nom du pays. Bien évidemment Title prend en paramètre un widget. J'aurai subtitle, je remettrai le même widget ; et enfin, vous pourrez avoir sur la partie gauche, un widget, ou sur la partir droite, à nouveau un widget. Ici, la partie gauche sera le leading. Je mettrai le widget CircleAvatar qui est un widget affichant une forme circulaire. À l'intérieur duquel je mettrai une couleur donc, j'utiliserai la propriété backgroundColor qui sera, vu qu'on est avec l'Union Européenne, de couleur bleue. Si je lance notre code, on a bien notre CircleAvatar qui grâce au leading est affiché à gauche, le titre ici et le sous-titre. Bien que très fonctionnelle, notre ListView actuelle présente l'inconvénient de précharger tous les éléments de la liste. Même ceux qui ne sont pas visibles à l'écran. Avec notre liste de 27 éléments, ce n'est pas vraiment un problème. Mais si l'on avait plutôt 500, voire 1 000 éléments avec un affichage un peu plus complexe, ce serait pas la solution la plus optimale. Pour remédier à cela, on va utiliser la ListView.builder. Immédiatement, j'ai un « warning » qui me dit que ListView.builder prend un argument requis qui est itemBuilder. itemBuilder va prendre une fonction qui aura deux paramètres : le contexte, je peux même supprimer le type, et un index qui est peut-être l'argument qui est le paramètre le plus important qui va nous permettre de pouvoir accéder aux éléments de notre liste. On n'a plus besoin de la propriété children, je vais donc juste récupérer le ListTile et je vais supprimer la propriété children. Ici, on va dans le corps de notre fonction anonyme et on va dire quoi retourner à chaque élément qui est donné en paramètre grâce à l'index. Ici, on va faire return, on va utiliser ListTile et on va utiliser l'index avec notre liste. J'aurai euroList crochet pour obtenir le nom du pays à la position index, je supprimerai le sous-titre et je veillerai à mettre un point virgule puisqu'on a une instruction grâce à l'utilisation du mot-clé return. Si je relance, on a donc bien notre liste qui s'affiche correctement, mais si je « scroll » tout en bas, apparaît un message d'erreur. Ce message d'erreur nous indique que nous essayons d'afficher plus d'éléments que nous n'avons dans notre liste. Pour corriger ce problème, je vais aller à mon ListViewbuilder et utiliser la propriété item.Count. Ici, je dirai que nous avons euroList.length élément que nous avons 27 éléments, ou du moins, nous avons le nombre d'éléments que contient euroList. En relançant, le problème est à présent corrigé. Nous avons ainsi vu comment utiliser une ListView, comment utiliser une ListViewbuilder qui, elle, va charger seulement les éléments qui sont affichés à l'écran et enfin, nous avons vu comment utiliser des ListTile.

### Aborder les stateful widgets

Dans cette vidéo, nous allons aborder la notion de StatefulWidget. Widget est simplement une classe. Pour créer notre propre widget et pouvoir ensuite le composer éventuellement avec d'autres widgets, on a la possibilité d'hériter de la classe StatelessWidget, comme ce qui apparaît actuellement dans le code. La notion de StatelessWidget est présentée dans une autre vidéo de cette formation. Nous pouvons aussi utiliser un StatefulWidget. Celui-ci va avoir un état et en fonction de son état, il pourra se rafraîchir. Ce n'est pas une règle absolue, mais de manière générale, si l'utilisateur peut interagir avec un widget, ce sera un StatefulWidget. Nous allons ainsi créer un nouveau widget qui permettra d'indiquer un message activé ou non activé en fonction de l'état d'un CheckBox. Pour ce faire, je vais utiliser le raccourci stf qui permettra de créer un StatefulWidget, que je vais appeler _CustomCheckBox. Je vais dès maintenant, l'instancier dans ma HomePage. Et on voit ici que deux classes ont été générées. La première va hériter de la classe StatefulWidget. D'ailleurs, cette classe possède une méthode qui va instancier une seconde classe qui est de type State. Une méthode importante ici sera la méthode Build qui va contenir notre arbre de widgets, comme on peut d'ailleurs le faire avec un StatelessWidget. La différence ici est que l'on pourra utiliser la fonction setState qui s'écrit ainsi, et qui va nous permettre d'indiquer qu'un changement d'état a eu lieu. Quand ce sera le cas, notre arbre de widgets sera à nouveau rafraîchi. On ferait ainsi à nouveau appel à notre méthode Build. Je vais commencer par créer une variable d'instance dans cette classe qui hérite de la classe State, que je vais appeler isChecked qui sera de type Booléen. Pour initialiser cette variable, je pourrais le faire directement en mettant à false. Mais un StatefulWidget nous propose une méthode qui s'appelle initState. Je pourrais à l'intérieur faire la plupart de mes initialisation. Ainsi, je vais mettre isChecked à false. Par ailleurs, on ne va plus utiliser un Container, mais plutôt un Row, puisque je vais mettre un CheckBox et à côté, un texte. Mon widget Row va prendre une liste d'enfants. Je vais commencer avec le CheckBox, qui va prendre deux paramètres requis. La première sera une valeur. Je vais mettre ma variable isChecked. Le deuxième paramètre, onChanged, va être déclenché à chaque fois qu'un utilisateur va interagir avec ma CheckBox. Ce paramètre-là va demander une fonction qui, elle-même, a pour paramètre un booléen. Je vais donc créer une fonction anonyme ayant pour paramètre un booléen que j'appellerai newValue. Et dans le corps de ma fonction, je mettrai que isChecked prend la nouvelle valeur, newValue. Enfin, à côté de ma CheckBox, j'aurai un texte et j'y passerai un message. J'en profite également pour redéfinir la taille de la police, fontSize que je vais mettre à 35 et je vais créer une variable message qui sera de type string. Elle sera initialisée avec la chaîne de caractères « Non activé », puisque par défaut, isChecked est à faux. Ici, il faudra bien sûr que je pense à modifier la variable message. Si isChecked est à vrai, alors, message prendra la chaîne de caractères « Activé ». Sinon, le message prendra la valeur « Non activé ». À présent, si je lance mon code, on a bien ma CheckBox, et à côté mon texte. Si je clique sur ma CheckBox, malheureusement, rien n'apparaît. Cela est normal puisque nous n'avons pas informé notre StatefulWidget qu'il fallait qu'il se rafraîchisse. Pour ce faire, je vais appeler la fonction setState et je vais couper-coller le code écrit précédemment. À présent, si je relance, notre widget Stateful fonctionne comme attendu.

### Créer des boutons et gérer les actions utilisateur

Nous allons voir comment utiliser des boutons, mais aussi comment ajouter la gestion d’événements sur n'importe quel widget Flutter. Pour commencer, nous avons un widget Center qui va nous centrer les différents widgets, suivi d'un widget Column qui nous disposera les widgets de manière verticale. On va commencer avec le widget TextButton. Celui-ci prend deux paramètres requis. Le onPressed qui prendra une fonction et qui permettra de dire quoi faire à chaque fois que l'on cliquera sur le bouton, ainsi qu'un second paramètre qui est un child qui sera tout simplement un widget et qui permettra de mettre un contenu à notre bouton. Je vais donc commencer par une fonction anonyme pour dire quoi faire. Cette fonction anonyme sera exécutée à chaque fois que l'on cliquera sur notre bouton et je vais afficher le mot clic. J'en profite pour préciser que je suis bien dans un StatelessWidget. Le fait de gérer l’événement ne me force pas ici à utiliser un StatefulWidget puisque je n'aurais pas besoin de rafraîchir l'écran. Si je voulais convertir par contre en StatelessWidget à StatefulWidget, il me suffirait de cliquer sur StatelessWidget, de venir sélectionner l'ampoule jaune et de cliquer sur Convert to StatefulWidget. Je vais ajouter comme widget child un texte où je mettrai : Cliquez ici. Je vais formater rapidement et à présent, si j'exécute mon code, on a bien notre bouton. Je vais afficher la console, donc, je vais sur Affichage > Console de débogage, et quand je vais cliquer sur mon TextButton, j'ai bien le message clic. Il faut aussi savoir que dans des précédentes versions de Flutter, le TextButton avait pour équivalent le FlatButton. Ils se ressemblent, avec quelques différences. Par exemple, le fait de pouvoir utiliser la propriété style, que l'on va voir dans quelques instants. Je vais ajouter un autre type de boutons qui s'appelle le OutlinedButton. Celui-ci était dans les précédentes versions utilisées en tant que OutlineButton. Je vais réxécuter mon code et on voit qu'effectivement, j'ai le même bouton que le TextButton sauf que cette fois-ci, il a été entouré d'un genre de liseré. En cliquant dessus, ça fonctionne. Enfin, un troisième type qui est souvent utilisé est le ElevatedButton. Le ElevatedButton, son équivalent était le RaisedButton. Celui-ci va avoir un bouton qui est un peu plus surélevé et dont l'intérieur sera de couleur unie. Ainsi, si je souhaitais modifier l'apparence de ce dernier bouton, j'utiliserais la propriété style. Celui-ci va prendre ce que l'on appelle un ButtonStyle qui va me permettre, par exemple, de pouvoir modifier le degré d'élévation. Je serais tenté de mettre directement la valeur que je souhaite. Malheureusement, je devrai passer par un MaterialStateProperty. J'ajouterai le .all et je mettrai à l'intérieur ma valeur, admettons 10. On voit qu'ici, il y a cette notion d'élévation. Je peux aussi modifier la couleur qui est actuellement bleue, qui est définie par mon thème par défaut, et je mettrai donc backgroundColor. Je vais juste revenir à la ligne. Et là aussi, je ne pourrai pas utiliser, admettons, Colors.teal. Je devrais à nouveau passer par un MaterialStateProperty.all et à l'intérieur, mettre ma valeur. L'avantage des boutons, c'est qu'ils gèrent nativement les événements tels que le clic. Néanmoins, je serai peut-être amené à devoir utiliser d'autres événements tels que le double clic, le drag and drop. Pour cela, je peux ajouter la gestion d’événements à n'importe quel de mes widgets. Je vais prendre, par exemple, un texte que je vais appeler Gestion d’événement, je vais mettre les doubles quotes. Et cette fois-ci, si je lance, j'ai bien mon texte qui s'affiche, mais bien évidemment, je ne peux pas cliquer dessus. Je vais l'envelopper avec un nouveau widget qui s'appelle GestureDetector. Celui-ci peut détecter de nombreux événements tels que ceux que j'ai cités précédemment, le double clic ou encore le drag and drop. Je vais pour le simple clic utiliser le onTap. Ici, je mettrai une fonction anonyme et j'afficherai clic détecté. Je relance mon code. Et maintenant, si je clique sur mon texte Gestion d’événement, j'ai bien mon clic détecté qui s'affiche sur la console. Nous avons ainsi vu comment utiliser des boutons Flutter, mais aussi comment ajouter la gestion d’événement sur n'importe quel widget Flutter.

## Réaliser une application complète en Flutter

### Découvrir le projet

Nous allons à présent développer entièrement une application Flutter. Je vais avant tout aller sur le site orangevalley caa.org puisqu'il s'agira d'une application permettant d'afficher une liste de vidéos du site fictif orangevalley.caa. qui est une association d'arts diffusant des vidéos faites par ses membres. L'API peut être observée à cette adresse, donc orangevalleycaa.org/api /videos avec un S et on se verra retourner des informations au format Json. On pourrait ici utiliser un nombre de données telles que, bien évidemment, l'URL de la vidéo, le nom, la description ou encore, une image donnant son aperçu. À présent, on va créer notre projet Flutter. Je vais lancer Visual Studio Code et aller sur la palette de commandes. Ici, je taperai Flutter et je sélectionnerai Flutter: New Project. Je donnerai pour nom « orange_valley_caa, je sélectionnerai ensuite le dossier où je souhaite sauvegarder mon projet et une fois mon projet généré, je vais supprimer tout ce qui a en dehors de la fonction main. Je vais appeler mon application « OrangeValleyApp » et je vais créer un StatelessWidget qui sera donc OrangeValleyAppp. Celle-ci retournera un widget MaterialApp qui prendra pour Home, un widget que nous appellerons « HomePage ». Je vais à présent aller au niveau du répertoire lib, le sélectionner et cliquer sur l'icône permettant la création d'un nouveau dossier. J'appellerai ce sous-dossier « pages », ensuite, je peux faire un clic droit : Nouveau fichier que j'appellerai home_page.dart. Ici, je taperai stl pour StatelessWidget et je créerai mon widget HomePage. Il faudra que je fasse un import pour pouvoir utiliser le StatelessWidget, je vais donc utiliser le package material.dart et ma HomePage va retourner non pas un Container, mais un « Scaffold ». Ici, je préciserai que l'on aura une appBar dont le titre sera le nom de l'association, donc Orange Valley CAA et au niveau du « body », je mettrai un Container vide. Enfin, je retournerai sur le main.dart, j'importerai ma HomePage, donc je clique sur l'ampoule et je sélectionne Import Library, et pour également pouvoir supprimer le petit bandeau qu'il y a en haut à droite affichant le « debug », le mieux est peut-être que je lance l'application, je vais donc cliquer sur Run, je vais sélectionner mon émulateur et une fois l'application lancée, je vais faire en sorte de supprimer ce petit bandeau debug. Pour ce faire, je vais aller au niveau de MaterialApp et je vais utiliser la propriété debugShowCheckedModeBanner que je mettrai à False. Si je relance, la bannière a bien disparu. Maintenant que nous avons mis en place notre projet Flutter, nous voilà prêts à écrire notre application

### Créer les modèles JSON

Comme on peut le voir à l'écran, l'API que nous allons utiliser nous retourne des données sous le format JSON. Pour pouvoir exploiter ces données dans notre application, il nous faudra décoder ce JSON. On va laisser de côté Visual Studio Code quelques instants pour aller sur le site « dartpad.dev ». Avant de voir comment décoder du JSON, nous allons nous intéresser à la collection Map. Une Map va contenir des clés associées à des valeurs, sachant que les clés devront être uniques, tandis que les valeurs n'auront pas besoin de l'être. Je vais ainsi préciser que ma Map aura des clés de type string et des valeurs associées de type int. Ma Map s'appellera myMap et je l'initialiserai grâce à une paire d'accolades. À l'intérieur, je préciserai le nom de ma première clé, je l'appellerai key1, suivi de deux points et de la valeur associée. Je mettrai donc un entier ici, 100. Je créerai une deuxième clé, key2, et je mettrai la même valeur, à savoir 100. Pour connaître la valeur associée à la clé key1, je taperai myMap suivi d'une paire de crochets et du nom de la clé. J'utiliserai la fonction print, et en exécutant le code, j'aurais bien 100 qui s'affiche à l'écran. Si j'avais voulu modifier la valeur de key1, je ferais « myMap['key1'] », et je lui effectuerais une nouvelle valeur. Ainsi, je pourrais mettre 200. Maintenant, si je relance, la valeur associée à key1 sera bien de 200. Regardons à présent comment décoder du JSON. Je vais créer une variable qui va contenir notre JSON. Je l'ai préalablement préparée. Pour pouvoir décoder ce JSON, je vais créer une autre variable qui s'appellera jsonDecoded. Je taperai ensuite json.decode suivi du JSON à décoder. Il faudra bien sûr penser à utiliser une librairie nous permettant d'appeler cette variable JSON. Pour ce faire, je ferai un import de dart:convert. Il faudra penser également au point virgule. À présent, je peux afficher le contenu de jsonDecoded, et en exécutant le code, on voit que le JSON a été converti en Map. À présent, si je veux accéder à une valeur de ma Map, je ferai comme on l'a vu précédemment, donc, je ferai jsonDecoded, crochets, et le nom de la clé. Je mettrai, par exemple, name. Je devrais ainsi avoir la valeur associée Steeve. Enfin, si mon JSON représentait une personne, je pourrais créer une classe Person puis définir les différentes propriétés, donc, name et age, et utiliser un constructeur nommé que j'appellerai fromJson. Ce constructeur prendra en paramètre une Map que j'appellerai data et pour initialiser mes attributs, je ferai donc deux points, « name = data['name'] », la clé, virgule, « age = data['age'] », et je termine par un point virgule. Pour l'utiliser, il me suffira d'instancier ma classe Person, donc, = Person.fromJson. Je passe ma map, le json.Decoded, et à présent, je peux afficher une propriété de person. Je vais afficher, par exemple, l'âge. Il est vrai ici que mon JSON est assez simple, et que, par conséquent, j'ai tout tapé à la main. Si le JSON était beaucoup plus conséquent, cela deviendrait peut-être un petit peu rébarbatif de devoir tout taper. Fort heureusement, il existe des sites qui permettent de générer automatiquement le code. On va aller sur un moteur de recherche, je vais taper json to dart, et sélectionner le site « quicktype ». Ici, je sélectionnerai le langage de programmation, donc Dart. J'irai dans les options et décocherai Detect enums. Enfin, je donnerai un nom à la classe qui devra être générée. Je mettrai video, je reviendrai sur mon JSON. Je ferai Cmd + A ou Ctrl + A sur Windows pour copier ensuite tout mon JSON. Je reviens sur le site « quicktype » et je vais dans cette zone coller le JSON que j'ai copié. L'outil m'a ainsi non seulement généré la classe Video avec la conversion du JSON, mais il m'a également généré des fonctions me permettant de récupérer une liste de vidéos à partir de JSON. Je vais à présent copier le code, donc, je clique sur Copy Code, et revenir sur Visual Studio Code. Pour organiser la structure de mon projet, je vais cliquer sur lib, créer un nouveau répertoire que j'appellerai models qui contiendra tous mes modèles tels que Video, par exemple, et je crée un nouveau fichier que j'appellerai video.dart, à l'intérieur duquel je collerai le code qui a été généré. Dans cette vidéo, nous avons vu comment utiliser une Map et comment décoder du JSON.

### Consommer l'API

Maintenant que nous pouvons décoder le format Json, nous allons pouvoir récupérer es informations depuis l'API. Pour pouvoir utiliser une connexion internet, il faut savoir qu'il est nécessaire pour les appareils Android d'en demander explicitement la permission. Veuillez noter qu'en mode « debug », c'est-à-dire en mode de développement comme c'est actuellement le cas, cette demande n'est pas obligatoire. Mais elle le deviendra si vous voulez publier votre application. On va ainsi aller dans le répertoire android > app > src > main et enfin, ouvrir le fichier AndroidManifest.xml. Ici, il faudra aller tout en bas du fichier et juste après le tag de fermeture application, ajouter la ligne suivante uses_permission pour la permission internet. Je finirai par sauvegarder les modifications et j'irai ensuite sur mon répertoire lib pour créer un sous-répertoire que j’appellerai « services ». À l'intérieur duquel je créerai un nouveau fichier que j’appellerai « video_api.dart ». Dans ce fichier, je créerai une fonction qui permettra de récupérer le Json depuis l'API. Néanmoins, pour récupérer des données sur internet, nous allons devoir ajouter à Flutter un package ; un package, c'est tout simplement une librairie, une bibliothèque partagée. On ira sur le site officiel pub.dev et on recherchera HTTP. Ici, on utilisera donc ce package et on ira cliquer sur l'onglet « Installing ». On pourra ainsi récupérer la dépendance à ajouter à notre fichier de configuration pubspec.yaml. Je reviens donc sur Visual Studio Code et je vais aller sur mon fichier de configuration. Il faudra bien copier au même niveau que Flutter. N'oubliez pas que en YAML, l'indentation a son importance. Je vais sauvegarder pour que l'ajout du package soit pris en considération et je vais ensuite retourner sur le site pub.dev pour avoir plus d'information sur la manière d'utiliser ce package. Il faudra que j'importe cette ligne-là. On voit aussi que ma fonction devra être async puisque la requête se fera de manière asynchrone et la partie la plus importante est ici. Je pourrais faire http.get avec l'URL en paramètre si le code de retour est égal à 200, donc si la requête s'est faite sans échec avec succès, je pourrais décoder mon fichier Json. Je vais donc copier les lignes suivantes et les ajouter à notre code pour pouvoir le configurer. Je vais donc ici, je vais d'abord peut-être créer ma fonction. Cette fonction-là, je vais l'appeler « getVideos FromApi ». Et dans le corps, je collerai ce que j'ai copié. Bien évidement, le fait d'utiliser un await fait que je dois mettre ici un async. Aussi, je devrai faire l'import, donc je vais copier la ligne suivante et l'ajouter à mon code. Je vais ajouter quelques modifications, par exemple ici, supprimer le corps, ici aussi, je vais également ajouter mon URL. Pour ce faire, je vais créer une constante que j'appellrai « url » et qui prendra mon URL. Quand l'URL aura été faite avec succès je pourrai récupérer mon Json de la manière suivante, donc var json response.body. Il me restera plus qu'à l'exploiter. Je ferai donc un « return videos », je me souviens plus très bien exactement du terme que l'on avait utilisé, donc je vais retourner ici, c'est videoFromJson, je retourne sur le fichier et je mettrai « return videoFromJson » de mon Json. Il faudra que je pense à importer la librairie et dans le cas contraire, dans le cas où vous aurez une erreur au niveau du réseau je retournerais une liste vide. Pour pouvoir tester mon code, je vais aller sur ma HomePage et ici, je vais appeler getVideosFromApi.then ; il y a un problème, c'est normal. J'ai oublié une chose, c'est d'indiquer quel est le type de retour. Ici, nous allons retourner un Future qui retournera la même chose que videosFromJson, donc une liste de vidéos. Je vais donc mettre « Future Videos ». Si je reviens sur homepage.dart, à présent, je pourrai faire un then puisqu'il me retourne un Future. Ici la valeur, ça sera la liste des vidéos et je ferai tout simplement un print sur value .length, pour obtenir le nombre d'éléments qu'i y a dans ma liste. Je vais sauvegarder et lancer mon code. Pour voir le résultat, il faudra quand même que je veille à afficher la console de débogage, donc je vais sur Affichage > Console de débogage. 

### Afficher une grille d'images grâce à une GridView

Nous allons voir comment on peut créer l'interface de notre « Home Page ». Pour cela, nous allons créer une liste affichant une vignette de chaque vidéo avec son titre. Néanmoins, nous n'utiliserons pas une ListView, mais plutôt une GridView. Cette dernière va afficher les éléments qu'elle contient, non pas de manière à en avoir un par ligne, même si cela est possible, mais elle aura plusieurs éléments par ligne. Dans l'explorateur de fichier ici à gauche, on peut voir en vert les répertoires et les fichiers que j'ai créés. Dans Utils, j'ai affiché constants.dart qui va centraliser mes constantes que je pourrais réutiliser dans mon application. J'y ai ainsi mis une constante backgroundColor qui permettra de définir la couleur d'arrière-plan. Dans le fichier helper.dart, j'ai créé une fonction temporaire que j'ai appelée « getFakeVideos » et qui va nous retourner une liste de vidéos. Cette liste est un simple extrait de notre API. Et cela va nous éviter pour le moment de faire des requêtes pour se focaliser uniquement sur l'interface utilisateur. Enfin, j'ai mis un dernier répertoire : le répertoire widgets qui contiendra tous les widgets qu'on est susceptible de créer. Le fichier qu'il contient, donc le fichier video_grid.dart aura tout le code de notre GridView. On va revenir sur le widget home page et on va définir les couleurs de cette page-là. Donc, dans mon Container, je vais mettre Color et je vais utiliser la constante que j'ai créée. Ensuite, je vais en profiter pour définir une couleur de la barre, donc j'utiliserai la propriété backgroundColor et je mettrai Colors.black. Je vais reformater mon code. Si je lance mon application, les couleurs ont bien été appliquées. Je vais à présent, dans mon container, utiliser le widget que j'ai créé, à savoir, le widget VideosGrid. Celui-ci prend en paramètre une liste de vidéos et pour récupérer cette liste, je vais utiliser la fonction que j'ai créée ici : getFakeVideos. Je vais donc l'appeler directement getFakeVideos. Ici, je lance notre code, on a bien notre GridView qui s'affiche. On constate que nous avons deux éléments par ligne et que pour chaque élément, nous avons une vignette qui s'affiche avec le titre en bas de la vidéo. Maintenant, regardons de plus prêt le code de VideosGrid. Je vais donc aller dans widgets et ouvrir le fichier videos_grid.dart. Ici, on a deux classes : une première classe VideosGrid et une seconde qui est dans le même fichier : _VideoTile. On va commencer avec VideosGrid qui est un StatelessWidget. VideosGrid va prendre une liste de vidéos qui sera initialisée dans le constructeur et dans la méthode build, on va retourner une GridView.count. GridView.count va prendre un premier paramètre crossAxisCount qui nous permettra de définir le nombre d'éléments par ligne. Par exemple, si à la place de deux, je vais bien mettre trois, j'aurai au maximum trois éléments par ligne. Je reviens sur deux. Il faudra bien évidemment définir les widgets enfin qui sont ici au nombre de quatre. Pour ce faire, je vais parcourir la liste vidéos. Pour chaque vidéo, je vais retourner le widget _VideoTile qui est défini juste en dessous et qui va prendre en paramètre l'URL de l'image, de la « thumbnail » ainsi que le nom de la vidéo. Regardons maintenant _VideoTile qui là aussi, est un StatelessWidget, donc on ne pourra pas faire appel, par exemple, à la fonction setState. On remarquera aussi que _VideoTile a un underscore, ce qui en fait une classe privée, donc je ne pourrai pas utiliser _VideoTile en dehors du fichier videogrid.dart, je ne pourrais pas par exemple, l'utiliser dans homepage.dart. _VideoTile va avoir donc sa méthode build qui va utiliser un « padding ». Le padding va nous permettre de mettre de l'espace entre les différents éléments, que ce soit à droite, à gauche, en haut ou en bas. Pour cela, j'ai mis une valeur de dix. Ensuite, pour pouvoir superposer l'image avec le titre, j'ai utilisé une « stack ». J'aurai donc deux parties : la partie Image qui sera un Container et une partie Titre où j'utiliserai un Aligne. Commençons avec l'image. L'image sera donc un Container pour lequel j'ai ajouté un ClipRRect. Le ClipRRect va découper mon Container et j'utiliserai un rebord arrondi. Ici, je lui mettrai une valeur de huit. Enfin, pour récupérer l'image, j'utiliserai Image.network. La seconde partie sera le Titre. J'utilise Aligne pour pouvoir dans ma stack, indiquer à quel endroit je dois placer justement le container qui est juste en dessous. Ici, j'ai indiqué en bas au centre. Mon container aura une couleur d'arrière-plan de type noir avec une opacité à 0,6 pour donner un effet semi-transparent. La hauteur de ce container sera fixe et sera de 35 et je mettrai un texte qui sera bien sûr centré et qui aura pour chaîne de caractères, le Titre qui est passé en paramètre au niveau du constructeur. Notre GridView étant maintenant construite, nous allons à présent pouvoir récupérer les données de l'API et les injecter directement dans notre GridView.

### Utiliser un FutureBuilder pour alimenter une GridView

Dans cette vidéo, regardons comment alimenter notre GridView grâce aux données envoyées par l'API. Une première façon de faire est de convertir notre HomePage en StatefulWidget. Une fois les donnée récupérées, on demandera à notre widget de se rafraîchir. Je vais donc cliquer sur StatelessWidget et le transformer en StatefulWidget. Dans la classe HomePageState, je vais rajouter une variable d'instance que j'appellerai « video » et qui sera initialisée avec une ListView, puis une fois les données récupérées depuis l'API, je vais faire un setState et préciser que videos va prendre la nouvelle valeur. Enfin, je veillerai à supprimer getFakeVideos pour le remplacer avec notre variable videos. Si je lance notre application, on a bien les données récupérées depuis notre API qui s'affichent à l'écran. Cette méthode est fonctionnelle, mais Flutter nous apporte une autre façon de faire grâce à l'utilisation du widget FutureBuilder. Un FutureBuilder va appeler une fonction retournant un futur et dès qu'un résultat sera généré, par exemple succès, une erreur ou tout simplement, l'attente d'une réponse, on pourrait décider quoi en faire. Ainsi, le FutureBuilder va nous donner plus de souplesse. Je vais revenir à la version Stateless du HomePage pour introduire le FutureBuilder. Je vais supprimer l'appel à getVideosFromApi et remplacer VideosGrid par un FutureBuilder. Je vais donc mettre FutureBuilder suivi de la virgule, je vais préciser grâce à la propriété Future, de quelle manière je vais récupérer mes données. Donc ici, il s'agira de getVideosFromApi, ensuite, je passerai un Builder qui prendra deux paramètres : context et snapshot et dans le corps de cette fonction anonyme, je préciserai que si le snapshot point connectionState, donc si l'état de la connexion est égal à ConnectionState.waiting, donc si on est en attente de la récupération des données, dans ce cas-là, je retournerai un widget qui sera centré et qui sera un CircularProgressIndicator. C'est également ce que l'on appelle un « spinner ». Sinon, si le snapshot contient des erreurs, donc hasError, dans le cas par exemple, où il y a un problème de connexion, dans ce cas-là, je retournerai là aussi, un center et je mettrai tout simplement un texte qui affichera l'erreur. Donc, snapshot.error. Enfin, il faut le point virgule. Enfin, dans les autres cas, donc dans le cas où tout se passe bien, je retournerai ma VideosGrid en passant bien sûr, le paramètre videos et là, je lui mettrai snapshot.data. Je vais reformater le code et je vais tout relancer, je ferai un « hot restart ». J'ai une erreur, il va falloir que je supprime une parenthèse en trop, je recommence. On voit ici très brièvement qu'il y a eu le spinner qui s'est affiché et enfin, on a récupéré nos données. Nous avons ainsi vu dans cette vidéo, comment récupérer les données grâce à notre fonction getVideosFromApi de deux façons : soit en utilisant un StatefulWidget ou encore, à travers l'utilisation d'un FutureBuilder.

### Créer un écran affichant les détails d'une vidéo

Nous allons concevoir la page affichant les détails d'une vidéo où nous nous focaliserons uniquement sur la partie interface utilisateur. Pour ce faire, nous n'allons pas pour le moment, utiliser les données récupérées depuis l'API, mais nous allons plutôt réutiliser la liste retournée par notre fonction getFakeVideos. Dans une autre vidéo, nous voyons comment passer de la page HomePage à la page DetailsPage qui est le widget que nous allons voir ici. Il faudra donc temporairement modifier le premier widget de l'application qu'on appelle aussi « root widget » qui dans le cas présent, s'appelle « OrangeValleyApp ». Ce dernier ne lancera donc pas HomePage, mais plutôt DetailsPage. Ce widget prendra en paramètre une vidéo, on appellera donc getFakeVideos et on récupérera la dernière vidéo de la liste. Si je lance l'application, on a bien les détails de la vidéo qui s'affichent à l'écran. À présent, ouvrons justement cette page. J'écris un nouveau fichier dans le sous-répertoire page que j'ai appelé « details_page ». En l'ouvrant, on voit que ce fichier est constitué de plusieurs widgets qui sont de type Stateless. Ainsi, si je reviens au début, on va commencer avec donc details_page qui est notre page qui va être lancée ; details_page prend donc une vidéo en paramètre et va créer le « Scaffold ». On va ainsi avoir la barre qui va prendre pour titre le nom de la vidéo ainsi que un « body » qui sera un « Container » dont la couleur sera notre constante backgroundColor. et qui prendra pour enfant, un widget qui s'appelle « _VideoDetail ». Celui-ci est juste en dessous, _VideoDetail va être constitué d'une ListView. Une ListView dand le sens où peut-être que les éléments qui seront affichés seront beaucoup plus grands que la taille de l'écran par exemple, si on a une description trop longue. Du coup, le ListView nous permettra de pouvoir « scroller » de haut en bas. Cette ListView va avoir un widget DetailsPoster qui va afficher l'image du haut. Ensuite, un SizedBox qui va simuler un espace entre l'image et la description, on a donc bien sûr la description juste après. À nouveau, un SizedBox qui est un peu plus grand et enfin, on terminera avec les « key words », les mots-clés qui seront affichés grâce à ce que l'on appelle des « Chips » qui sont des widgets affichant une forme ovale. Si je regarde maintenant le contenu de DetailsPoster, je vois que celui-ci prend une URL qui est bien évidement l'URL de l'image et va tout simplement avoir un Container avec une hauteur de 200 et va afficher l'image grâce à Image.network et adaptera cette image-là en fonction de la largeur. Ensuite, en dessous de l'image, on aura la description. La description cette fois-ci, sera une méthode qui sera contenue dans la classe _VideoDetails. Elle se trouve juste ici, c'est une méthode qui retourne un widget et qui se contente simplement d'afficher le contenu de video.description. La question qui peut se poser est pourquoi ici j'utilise mes méthodes de retourner un widget ? Tandis que pour le poster ou même pour les autres éléments, j'utilise des Stateless widgets. Tout simplement parce que je souhaitais vous montrer qu'il y a les deux possibilités, sachant qu'il est fortement recommandé de créer plutôt des Stateless widgets en lieu et place de méthodes retournant des widgets. Si on continue au-delà de la description, on termine avec les keywords. Les keywords vont utiliser bien évidemment un centrage, on va essayer de centrer les différents éléments. Mais la partie qui est intéressante sera le « Wrap », le Wrap va permettre d'éviter « l'Overflow ». Dans le sens où s'il y a trop d'éléments et que ceux-ci ne peuvent se contenir dans la largeur de notre écran, le Wrap va venir les mettre à la ligne suivante. Aussi, les keywords, on nous les retourne sous forme de chaînes de caractères séparées par des virgules. J'ai donc utilisé keywords.split pour nous créer une nouvelle liste où chaque élément sera séparé par la virgule. Je vais ainsi parcourir cette nouvelle liste et afficher grâce au widget Chip, le genre qui nous est retourné. Dans cette vidéo, nous avons vu ainsi comment créer notre page de détail d'une vidéo.

### Ajouter et utiliser une police d'écriture

Dans cette vidéo, nous allons voir comment ajouter et utiliser de nouvelles polices de caractères. En effet, dans la description actuelle, nous utilisons une police de caractères par défaut. On va ainsi commencer par créer un nouveau dossier dans notre répertoire que l'on appellera fonts. Le nom importe peu et nous irons ensuite sur Internet et ferons une recherche sur google fonts. De là, je sélectionnerai le site Google Fonts et je ferai une recherche sur la police Castoro. Ici, il ne me restera plus qu'à la sélectionner et à télécharger les fichiers. Une fois le téléchargement terminé, nous serons en présence de deux fichiers TTF, l'un pour le style normal et l'autre pour le style italique. Je vais ainsi déplacer les fichiers téléchargés. Je vais donc légèrement déplacer mon explorateur de fichiers. Sélectionner les deux fichiers et les déplacer. Maintenant, il va falloir que je modifie mon fichier « pubspec.yaml » pour l'informer que j'ai ajouté deux nouveaux fichiers. Je descendrai ici jusqu'à la partie flutter et j'ajouterai, en prenant bien évidemment en compte l'indentation : « fonts: », je mettrai en dessous un « - family » et je mettrai Castoro. Le nom de la famille importe peu, vous pouvez utiliser le nom que vous souhaitez. Je peux, par exemple, mettre CastoroCustom. Ensuite en dessous, je rajouterai « fonts: » suivi d'un tiret, et je mettrai asset, puis le chemin jusqu'à ma police. Ici, ça sera donc « Castoro-italic.ttf ». Et je préciserai qu'il s'agit d'un style italique. Je copierai cette ligne pour ajouter la seconde police qui, par contre, cette fois-ci sera normale, sera régulière. Ensuite, j'irai sur ma page de détail. Pour ajouter la nouvelle police, j'irai donc dans le style et je mettrai fontFamily, et là, j'avais mis CastoroCustom. Je vérifie que je ne me suis pas trompé. CastoroCustom, pour être sûr, je vais le copier-coller. Et à présent, je vais lancer notre application. Pour que l'ajout de la police soit pris en considération, il va falloir que je coupe l'application et que je la relance. On voit à présent que la police a été modifiée. Pour utiliser le style italique, je mettrai fontStyle et là, je mettrai « FontStyle.italic ». J'ai oublié la virgule au-dessus. Si je sauvegarde, le style italique a été utilisé. Avant de terminer, je souhaite préciser qu'il y a un package qui fait la même chose. Ainsi, si je vais sur pub.dev et que je tape google fonts, on voit qu'il y a un package, d'ailleurs, qui est parmi les Flutter Favorite. Donc, vous pouvez vraiment l'utiliser avec confiance et qui fait exactement la même chose que ce que nous venons de faire, mais de manière simplifiée.

### Naviguer entre les écrans

Nous allons apprendre à naviguer entre les différentes pages de notre application. Dans notre fichier main.darts, on commencera par remettre le widget HomePage comme étant la première page affichée à l'écran. Pour pouvoir ouvrir le détail d'une vidéo, il nous faudra dans un premier temps, détecter le clic sur les différents éléments de la GridView, puis dans un second temps, on ouvrira la page de détail en lui transmettant un objet vidéo. On va ouvrir notre widget VideosGrid pour faire en sorte que chaque élément de type VideoTile puisse être cliquable. On utiliserait ainsi un GestureDetector. Je vais donc sélectionner VideoTile ici et cliquer sur l'ampoule pour enfin sélectionner Wrap with widget. Ici, je mettrai GestureDetector et j'utiliserai la propriété onTap pour détecter un clic. J'afficherai un simple message : clic. Ainsi, si je relance notre code, j'en profite pour afficher la console de débogage et en cliquant sur un des éléments VideoTile, j'ai bien le message clic qui s'affiche. Nous allons remplacer notre print par l'utilisation d'un Navigator qui permettra d'afficher à l'écran une nouvelle page. Je mets donc Navigator point push. Je devrai ici donner un contexte et une route. Pour cette dernière, j'utiliserai un Material PageRoute. Celui-ci assurera également l'animation de transition entre les deux pages et retournera la page de détail. Je vais donc mettre le contexte pour retourner mon DetailsPage qui prend en paramètre une vidéo qui est celle qui est affichée actuellement. Je vais juste faire un import. À présent, si je lance notre code et que je clique sur un des éléments, j'ai bien la page de détail qui s'affiche. Nous avons ainsi vu comment communiquer entre deux pages différentes de notre applications. On peut améliorer l'affichage en utilisant ce que l'on appelle un « Hero ». Un Hero est tout simplement une animation qui va agrémenter la transition d'une page à l'autre. Pour l'utiliser, je vais aller dans la partie représentant mon VideoTile, en particulier, la section concernant l'image. Ici, je vais envelopper mon Container avec un widget Hero. Ce widget va prendre un paramètre qui est l'argument tag. Ici, je devrais donner un identifiant unique pour pouvoir faire la correspondance entre les deux Hero : celui de la première page et celui de la seconde page ; j'utiliserai imageUrl. À présent, je vais dans DetailsPage et je vais faire la même chose pour l'image. Je vais donc venir ici, je vais créer un Hero, j'ajoute le tag et je précise ce que tag est posterUrl. Je vais à présent sauvegarder, je reviens en arrière et quand je vais cliquer, j'ai bien la transition qui se fait de manière beaucoup plus fluide. Dans cette vidéo, nous avons ainsi vu comment naviguer au sein de notre application et comment utiliser le widget Hero.

### Proposer un menu pour modifier l'affichage

Nous allons voir comment ajouter des actions à une AppBar. J'ai ajouté du code à notre application pour pouvoir filtrer les vidéos selon l'identifiant qui est le filtre Par défaut ou bien Par nom ou Par durée. On va à présent ouvrir le fichier « helper.dart ». J'ai créé ce que l'on appelle une énumération grâce au mot clé enum, suivi du nom de mon énumération que j'appellerai VideoSort. Celle-ci ne pourra contenir que trois valeurs qui correspondent aux trois types de filtres que l'API accepte. Pour accéder, par exemple, au nom, donc ici, name, je ferai VideoSort.name. Aussi, pour récupérer la valeur sélectionnée dans l'énumération, mais également à titre d'exemple, j'ai créé une extension sur VideoSort, le nom importe peu, mais le plus important à retenir, c'est que celle-ci va venir enrichir l'énumération de nouvelles fonctionnalités. Je pourrais ainsi, grâce à filterName, pouvoir récupérer seulement le nom et non pas VideoSort.name. En allant à présent dans video_api.dart, on voit que j'ai ajouté un paramètre nommé à notre fonction qui, par défaut, sélectionnera le filtre par identifiant. J'ai également modifié l'URL en conséquence pour indiquer à l'API quel type de filtre je souhaite récupérer. Enfin, dans la HomePage, à travers la propriété actions qui prend une liste de widgets, j'ai créé un PopupMenuButton qui me permet d'afficher une icône de filtre, comme on peut le voir ici. Le Offset que j'utilise ici permet d'afficher cette Popup en dessous de la barre pour avoir un meilleur aspect visuel. Puis, j'ai défini les différentes possibilités de filtres grâce à des widgets PopupMenultem. Je vais à présent de voir transformer ma HomePage en StatefulWidget pour pouvoir rafraîchir les données, chaque fois qu'un filtre sera sélectionné. Je procède donc à la conversion comme on a l'habitude de le faire, et je vais ajouter une variable d'instance que je vais appeler _selectedFilter. Par défaut, celle-ci prendra la valeur VideoSort.id. PopupMenuButton ici prend une propriété qui s'appelle onSelected. Celle-ci va faire appel à une fonction. Je vais l'appeler onChangeFilter et je vais demander à VS Code de me générer la méthode. À présent, je vais définir le corps de cette nouvelle méthode. Alors ici, je mettrai non pas value, mais plutôt choice que je trouve plus parlant, et je vais dire que si le nouveau choix sélectionné est différent de selectedFilter donc, on va éviter ainsi de devoir rafraîchir notre arbre de widgets si ce n'est pas utile, je ferai donc un setState où j'indiquerai que selectedFilter prend la nouvelle valeur, donc choice. Il faudra aussi que au niveau de mon FutureBuilder, j'indique qu'à présent, j'ai un filtre qui est selectedFilter. Je ne pourrais pas faire du hot reload, je devrais redémarrer l'application pour que les changements soient pris en considération. À présent, si je sélectionne un nouveau filtre et non pas celui Par défaut, par exemple, Par nom, j'ai bien ma GridView qui est rafraîchi. Je vais essayer avec la durée. Tout fonctionne comme on l'espérait. Dans cette vidéo, nous avons ainsi vu comment ajouter des actions à une AppBar, mais nous avons également vu comment créer une énumération ou une extension.

### Assurer la lecture vidéo

Notre application serait incomplète sans la présence de la lecture vidéo. Nous allons ainsi voir comment l'implémenter. Pour pouvoir lire les vidéos, il faudra faire appel à un package ajoutant cette fonctionnalité. Retournons sur pub.dev, on va saisir le mot-clé « vidéo » sachant que le package officiel est « video_player ». Néanmoins, nous allons utiliser la package Chewie qui est basé lui-même sur video_player, mais qui en facilite son utilisation. Pour l'installer, on procédera de la manière habituelle en cliquant sur l'onglet « Installing » et en copiant la ligne suivante dans notre fichier pubspec.yaml. Une fois la ligne ajoutée, il ne faudra pas oublier de sauvegarder les modifications, de couper l'application si elle est déjà lancée, puis de la relancer. Voyons à présent le résultat obtenu à partir des ajouts de code effectués. Je vais donc sélectionner une vignette, je vais prendre celle-ci et sur la nouvelle page de détail d'une vidéo, on voit que une icône de lecture a été ajoutée. Je vais ainsi ouvrir details_page.dart et aller sur le widget gérant l'affichage de l'image. Ici, sur DetailsPoster, on voit que j'ai utilisé un GestureDetector pour pouvoir détecter le clic qui se fera sur l'image. Une fois le clic détecté, celui-ci, le GestureDetector, nous permettra d'ouvrir la nouvelle page qui s'appelle « VideoPlayerScreen » et qui prend en paramètre, l'URL de la vidéo. Pour avoir l'URL de la vidéo, il a fallu ajouter un nouveau champ : videoUrl qui sera initialisé dans notre constructeur. Pour pouvoir également faire cet effet superposé de l'image avec l'icône de lecture, on a utilisé une « stack » où on a en première partie de l'image, comme ce que nous avions précédemment, ainsi que l'icône de lecture. Pour avoir une taille aussi grande, il a fallu définir la propriété Size à 200 et modifier la couleur en utilisant du blanc. Si je clique à présent sur la lecture, j'ai bien mon VideoPlayer qui s'affiche ici. On va aller voir justement cette nouvelle page. J'ai ajouté un video_player_page.dart qui va contenir un widget de type Stateful et qui va avoir quelques parties intéressantes, à savoir un Controller qui va être un VideoPlayerController qui va prendre en paramètre l'URL de l'image que l'on veut récupérer. D'ailleurs, j'en profite pour préciser un point intéressant, c'est que quand on a dans notre constructeur un paramètre et qu'on veut l'utiliser dans la classe State, il suffit d'utiliser widget point, le nom du paramètre qui a été passé. Ensuite, ce Controller va être initialisé et pour terminer, on va utiliser un ChewieController qui lui, nous permettra d'ajouter des fonctionnalités. On pourra par exemple, définir si on veut l' « auto-play » ou si on veut un « looping ». La méthode qui est redéfinie ici, dispose sera appelée une fois que le widget sera détruit. On veillera donc à libérer les ressources qui ont été utilisées par nos différents Controllers. Au niveau du build, cela se fait de manière classique, on a un « scaffold » avec la barre, la couleur : backgroundColor qui a été définie dans le fichier constants.dart. Et on voit ici que on utilise un FutureBuilder puisque la récupération des données devra se faire de manière asynchrone. Lors du chargement, on procédera là aussi de manière habituelle en affichant un « spinner » qui tournera. Et une fois que la connexion aura été établie et qu'on aura récupéré les données, on pourra afficher notre vidéo grâce au chewie et on utilisera une aspiration pour garder les bonnes proportions de la vidéo. Si vous utilisez un appareil iOS, il faut savoir que la lecture vidéo ne marchera pas sur le simulateur. Il faudra utiliser un téléphone ou une tablette physique. Par ailleurs, sur Android, pour que la lecture fonctionne, j'ai dû ajouter un fichier de configuration de réseau pour les dernières versions d'Android. Je suis donc allé sur le répertoire android, dans le répertoire res et enfin, j'ai créé un nouveau répertoire qui s'appelle « xml ». À l'intérieur duquel j'ai créé un fichier que j'ai nommé « network_security_config.xml » et qui contient le xml suivant. Celui-ci autorise les requêtes vers le domaine orangevalleycaa.org, même si la connexion n'est pas sécurisée ; car en effet, l'API nous retourne une adresse en HTTP et non en HTTPS. On peut le voir d'ailleurs ici : au niveau de video_url, on a bien un HTTP. La connexion n'est donc pas sécurisée. Il faudra ensuite ajouter ce fichier de configuration dans le fichier Manifest au niveau du « tag » application. Il y a deux façons de le faire : soit on utilise comme j'ai pu le faire ici, « android: usesCleartextTraffic » est égal à True, le CleartextTraffic suffit pour les versions d'Android inférieures à l'API 28 qui correspond à Androit 9. Pour les autres versions, il faudra utiliser la ligne suivante, donc utiliser le fichier que nous venons de créer. Nous avons ainsi vu comment nous pouvons faire une lecture vidéo depuis notre application Flutter.